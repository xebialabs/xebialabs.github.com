<html><head><LINK REL=StyleSheet HREF="css/deployit.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="css/ci-reference-api.css" TYPE="text/css" MEDIA=screen>
<script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
<script type="text/javascript" src="js/jquery.tableofcontents.min.js"></script>
<script type="text/javascript" charset="utf-8">
$(document).ready(function(){
    document.body.id = "top-toc";
    var title = $("<div class='manual-title'/>")
    title.html("<div class='title'>Customization Manual</div><div class='version'>Version <span class='version-number'>3.5.2-SNAPSHOT</span></div>");
    $("body").css('width', '100%');
    $("body").prepend(title);
    $("body").prepend($("<ol id='toc'/>"));
    $("#toc").tableOfContents("body", { topLinks: true, } );
});

</script>
<title>Customization Manual</title>
</head><body><h1>Preface</h1><p>This manual describes how to customize Deployit for use in your environment.</p><h1>Introduction</h1><p>The Deployit deployment automation platform provides out of the box deployment capabilities for several middleware platforms. Some customers, however, will want to deeply integrate Deployit in their environment or deploy to middleware stacks that Deployit does not support out of the box. Tailoring deployment plans, adding support for new middleware and integrating with other systems are all possible by customizing the Deployit system. This manual describes what customizations are possible and how to adapt Deployit to fit in your environment.</p><p>This manual will first describe the Deployit system architecture to give a feel for where customizations fit in the system. Then, the role of Deployit extensions (plugins) in the deployment process is described. Next, the different ways of customizing Deployit are described.</p><h1>Customization Overview</h1><p>Deployit is designed with extensibility in mind and provides several different ways to modify it's behavior. Depending on the extender's skill set and requirements, one or more of these methods can be used to achieve the desired result.</p><p>These are the ways in which Deployit can be customized:</p>
<ul>
  <li>adding or modifying CIs by customizing the Deployit type system</li>
  <li>adding or modifying CI behavior by customizing one of the plugins provided by XebiaLabs</li>
  <li>adding Deployit Server functionality by providing server plugpoint implementations</li>
  <li>adding custom CIs and deployment functionality by writing a new plugin</li>
</ul><p>Each of these types of customizations are described in the remainder of this document.</p><h1>Customizing the Deployit Type System</h1><p>Today's middleware products are complicated and support lots of configuration options. Deployit plugins represent this middleware to the Deployit system. If a plugin wants to be a direct representation of the options in the middleware, it will quickly grow very large and unwieldy. Deployit provides a better way.</p><p>Given a CI defined in a plugin, an extender can customize this CI by adding new <em>synthetic properties</em> to the Java class, or by using the type system to extend the CI. These additions can either be done using plain Java, or by defining them in an XML file called <em>synthetic.xml</em> which can be added to the Deployit classpath. Changes to the types are loaded when the Deployit server starts and can be used to perform deployments.</p><h2>Modifying Existing CIs</h2><p>Types existing in Deployit can be modified to contain additional <em>synthetic properties</em>. These properties become a part of the CI type and can be specified in the deployment package and shown in the Deployit GUI.</p><p>There are several reasons to modifys:</p>
<ul>
  <li>a CI property is always given the same value in your environment. Using synthetic properties, the property can be given a default value and hidden from the user in the GUI.</li>
  <li>an existing CI could be extended with additional information.</li>
  <li>there are additional properties of an existing CI that you want to specify. For example, suppose there is a CI representing a deployed datasource for a specific middleware platform. The middleware platform allows the user to specify a connection pool size and connection timeout and Deployit supports the connection pool size out of the box. In this case, modifying the CI to add a synthetic property allows the user to specify the connection timeout. <strong>Note that this new synthetic property still needs to be communicated to the target middleware platform by the plugin. Consult the plugin manual for details of how to ensure the new property and its value are passed to the target middleware.</strong></li>
</ul><p>The following information can be specified when modifying a CI:</p>
<table class="deployed-matrix">
	<tr>
		<th>Property</th>
		<th>Required?</th>
		<th>Meaning</th>
	</tr>
	<tr>
		<td>type</td>
		<td>Yes</td>
		<td>Specifies the CI type to modify</td>
	</tr>
</table><p>Additionally, any property that is modified is listed as a nested <code>property</code> element. For each property, the following information can be specified:</p>
<table class="deployed-matrix">
	<tr>
		<th>Property</th>
		<th>Required?</th>
		<th>Meaning</th>
	</tr>
	<tr>
		<td>name</td>
		<td>Yes</td>
		<td>Specifies the name of the property to modify</td>
	</tr>
	<tr>
		<td>kind</td>
		<td>No</td>
		<td>Specifies the type of the property to modify. Possible values are: enum, boolean, integer, string, ci, set_of_ci, set_of_string, map_string_string</td>
	</tr>
	<tr>
		<td>description</td>
		<td>No</td>
		<td>Describes the property</td>
	</tr>
	<tr>
		<td>category</td>
		<td>No</td>
		<td>Categorizes the property. Each category is shown in a separate tab in the Deployit GUI</td>
	</tr>
	<tr>
		<td>label</td>
		<td>No</td>
		<td>Sets the CI's label property ???</td>
	</tr>
	<tr>
		<td>required</td>
		<td>No</td>
		<td>Indicates whether the property is required or not</td>
	</tr>
	<tr>
		<td>password</td>
		<td>No</td>
		<td>Indicates whether the property stores a password. If so, the property value is masked in the Deployit GUI and CLI</td>
	</tr>
	<tr>
		<td>size</td>
		<td>No</td>
		<td><b>Only relevant for properties with kind `string`.</b> Specifies the property size. Possible values are: default, small, medium, large. Large text fields will be shown as a textarea in the Deployit GUI</td>
	</tr>
	<tr>
		<td>default</td>
		<td>No</td>
		<td>Specifies the default value of the property</td>
	</tr>
	<tr>
		<td>enum-class</td>
		<td>No</td>
		<td><b>Only relevant for properties with kind `enum`.</b> Specifies the class of the enumeration that contains the possible values for this property</td>
	</tr>
	<tr>
		<td>referenced-type</td>
		<td>No</td>
		<td><b>Only relevant for properties with kind `ci`, `set_of_ci`.</b> Specifies the type of the referenced CI(s)</td>
	</tr>
	<tr>
		<td>as-containment</td>
		<td>No</td>
		<td><b>Only relevant for properties with kind `ci`, `set_of_ci`.</b> Indicates whether the property is modeled as containment in the repository. If true, the referenced CI or CIs are stored under the CI</td>
	</tr>
	<tr>
		<td>hidden</td>
		<td>No</td>
		<td>Indicates whether the property is hidden. Hidden properties don't show up in the Deployit GUI. Note that a hidden property must have a default value</td>
	</tr>
	<tr>
		<td>transient</td>
		<td>No</td>
		<td>Indicates whether the property is persisted in the repository or not</td>
	</tr>
</table><p>Here are some examples of modifying a CI.</p><h3>Hiding a CI Property</h3><p>The following XML snippet hides the <code>connectionTimeoutMillis</code> property and gives it a default value:</p>
<pre><code>&lt;type-modification type=&quot;base.Host&quot;&gt;
    &lt;property name=&quot;connectionTimeoutMillis&quot; kind=&quot;integer&quot; default=&quot;1200000&quot; hidden=&quot;true&quot; /&gt;
&lt;/type-modification&gt;
</code></pre><h3>Extending a CI</h3><p>For example, you could add a notes field to a CI to record notes:</p>
<pre><code>&lt;type-modification type=&quot;overthere.Host&quot;&gt;
    &lt;property name=&quot;notes&quot; kind=&quot;string&quot;/&gt;
&lt;/type-modification&gt;
</code></pre><h2>Defining new CIs</h2><p>It is also possible to define new CIs using this mechanism. By specifying a new type, it's base (either a concrete Java class or another synthetic type) and namespace, a new type will become available in Deployit. This means the CI type can be a part of deployment packages and created in the Repository browser. Each of the three categories of CIs (deployables, deployeds and containers) can be defined this way. </p><p>The following information can be specified when defining a new type:</p>
<table class="deployed-matrix">
	<tr>
		<th>Property</th>
		<th>Required?</th>
		<th>Meaning</th>
	</tr>
	<tr>
		<td>type</td>
		<td>Yes</td>
		<td>Specifies the CI type name</td>
	</tr>
	<tr>
		<td>extends</td>
		<td>Yes</td>
		<td>Specifies the parent CI type that the CI type inherits from</td>
	</tr>
	<tr>
		<td>description</td>
		<td>No</td>
		<td>Describes the new CI</td>
	</tr>
	<tr>
		<td>virtual</td>
		<td>No</td>
		<td>Specifies whether the CI is virtual (used to group together common properties) or not. Virtual CIs can not be used in a deployment package</td>
	</tr>
	<tr>
		<td>deployable-type</td>
		<td>No</td>
		<td><b>Only relevant for deployed CIs.</b> Specifies the deployable CI type that the CI deploys</td>
	</tr>
	<tr>
		<td>container-type</td>
		<td>No</td>
		<td><b>Only relevant for deployed CIs.</b> Specifies the container CI type that the CI is deployed to</td>
	</tr>
	<tr>
		<td>generate-deployable</td>
		<td>No</td>
		<td><b>Only relevant for deployed CIs.</b> Specifies the deployable CI type to be generated. This property is specified as a nested element</td>
	</tr>
</table><p>For each defined CI, zero or more properties can be specified. See the section above for more information.</p><p>Here is an example for each of the CI categories.</p><h3>Defining a Deployable CI</h3><p>Usually, deployable CIs are generated by Deployit (see the <code>generate-deployable</code> element above). The following snippet shows an example of defining a deployable manually:</p>
<pre><code>&lt;type type=&quot;acme.CustomWar&quot; extends=&quot;jee.War&quot;&gt;
    &lt;property name=&quot;startApplication&quot; kind=&quot;boolean&quot; required=&quot;true&quot;/&gt;
&lt;/type&gt;
</code></pre><h3>Defining a Container CI</h3><p>This XML snippet shows how to define a new container CI:</p>
<pre><code>&lt;type type=&quot;tc.Server&quot; extends=&quot;generic.Container&quot;&gt;
    &lt;property name=&quot;home&quot; default=&quot;/tmp/tomcat&quot;/&gt;
&lt;/type&gt;
</code></pre><h3>Defining a Deployed CI</h3><p>This XML snippet shows how to define a new deployed CI:</p>
<pre><code>&lt;type type=&quot;tc.WarModule&quot; extends=&quot;udm.BaseDeployedArtifact&quot; deployable-type=&quot;jee.War&quot;
      container-type=&quot;tc.Server&quot;&gt;
    &lt;generate-deployable type=&quot;tc.War&quot; extends=&quot;jee.War&quot;/&gt;
    &lt;property name=&quot;changeTicketNumber&quot; required=&quot;true&quot;/&gt;
    &lt;property name=&quot;startWeight&quot; default=&quot;1&quot; hidden=&quot;true&quot;/&gt;
&lt;/type&gt;
</code></pre><p>The <em>tc.WarModule</em> CI is generated when a <em>tc.War</em> is deployed to a <em>tc.Server</em>. The new CI inherits all properties from the <em>udm.BaseDeployedArtifact</em> CI and adds the required property <code>changeTicketNumber</code>. The <code>startWeight</code> property is hidden from the user with a default value of 1.</p><h1>Customizing Out of the Box Plugins</h1><p>Using the Deployit type system, the out of the box plugins can be customized. New CI properties or scripts can be added to supplement the functionality delivered by the plugin. More information about this can be found in the respective plugin manuals.</p><h1>Customizing Deployit Server using Plugpoints</h1><p>Functionality in the Deployit server core can be customized by using <em>plugpoints</em>. Plugpoints are specified and implemented in Java. On startup, Deployit scans it's classpath for implementations of its plugpoints and prepares them for use. There is no additional configuration required.</p><p>Deployit supports the following plugpoints:</p>
<ul>
  <li><em>protocol</em>: specify a new method for connecting to remote hosts</li>
  <li><em>deployment package importer</em>: allow Deployit to import deployment packages in a custom format</li>
</ul><h2>Defining Protocols</h2><p>A protocol in Deployit is a method for making a connection to a host. Overthere, Deployit's remote execution framework, uses protocols to build a connection with a target machine. Protocol implementations are read by Overthere when Deployit starts.</p><p>Classes implementing a protocol must adhere to two requirements:</p>
<ul>
  <li>the class must implement the <em>OverthereConnectionBuilder</em> interface</li>
  <li>the class must have the <em>@Protocol</em> annotiation</li>
</ul><p>The <em>OverthereConnectionBuilder</em> interface specifies only one method, <em>connect</em>. This method creates and returns a subclass of <em>OverthereConnection</em> representing a connection to the remote host. The connection must provide access to files (<em>OverthereFile</em> instances) that Deployit uses to execute deployments.</p><p>For more information about these classes and interfaces, see the <a href="http://support.xebialabs.com">Overthere Javadoc</a>.</p><h2>Defining Importers and ImportSources</h2><p>An <em>importer</em> is a class that turns an source into a collection of Deployit entities. Both the import source as well as the importer can be customized. Deployit comes with a default importer that understands the DAR package format (see the <strong>Packaging Manual</strong> for details).</p><p>Import sources are classes implementing the <em>ImportSource</em> interface and can be used to obtain a handle to the deployment package file to import. Import sources can also implement the <em>ListableImportSource</em> interface, which indicates they can produce a list of possible files that can be imported. The user can make a selection out of these options to start the import process.</p><p>When the import source has been selected, all configured importers in Deployit are invoked in turn to see if any importer is capable of handling the selected import source (the <em>canHandle</em> method). The first importer that indicates it can handle the package is used to perform the import. Deployit's default importer is a fallback.</p><p>First, the <em>preparePackage</em> method is invoked. This instructs the importer to produce a <em>PackageInfo</em> instance describing the package metadata. This data is used by Deployit to determine whether the user requesting the import has sufficient rights to perform it. If so, the importer's <em>importEntities</em> method is invoked, allowing the importer to read the import source, create deployables from the package and return a complete <em>ImportedPackage</em> instance. Deployit will handle storing of the package and contents.</p><h1>Adding Custom Plugins</h1><p>Writing a custom plugin is the most powerful way to extend Deployit. It uses Deployit's Java plugin API which is also used by all of the plugins delivered out of the box. The plugin API specifies a contract between Deployit core and a plugin that ensures that a plugin can safely contribute, along with other plugins, to the calculated deployment plan. To understand the plugin API, it is helpful to learn about the Deployit system architecture and how the plugins are involved in performing a deployment. The following sections provide this background information and are followed an explanation of how to build your own plugin.</p><h2>Deployit Architecture</h2><p>Deployit features a modular architecture that allows components to be changed and extended while maintaining a consistent system. The following diagram provides a high-level overview of the system architecture:</p><p><img src="images/deployit-architecture.png"  alt="Deployit Architecture"/></p><p>Deployit's central component is referred to as the <em>core</em> and contains the following functionality:</p>
<ul>
  <li>the Unified Deployment Engine which determines what is required to perform a deployment</li>
  <li>storage and retrieval of deployment packages</li>
  <li>executing and storing of deployment tasks</li>
  <li>security</li>
  <li>reporting</li>
</ul><p>The Deployit core is accessed using a REST service. The product ships with two clients of the REST API, a graphical user interface (GUI) built in Flex that run in browsers, and a command-line interface (CLI) that run Jython.</p><p>Support for various middleware platforms is provided in the form of <em>plugins</em>. Plugins add capabilities to Deployit and may be delivered by XebiaLabs or custom-built by users of Deployit. </p><h2>Deployit and Plugins</h2><p>A Deployit plugin is a component that provides the Deployit server with a way to interact with a specific piece of middleware. It allows the generic Deployit core to remain independent of the middleware it connects with. At the same time, it allows plugin writers to extend Deployit in a way that seamlessly integrates with the rest of Deployit's functionality. Plugins can be further extended by customers to customize Deployit for their environment.</p><p>To be able to integrate with the Deployit core, the plugins adhere to a well-defined interface. This interface describes the responsibilities of the plugin and the core and makes it clear what each can expect of the other. The Deployit core is the active party in this collaboration and it invokes the plugin whenever needed. The plugin, for it's part, replies to requests it is sent. When the Deployit server starts, it scans its classpath for plugins and loads each plugin it finds, readying it for interaction with the Deployit core. The Deployit server does not process changes to loaded plugins or load any new plugins after it has started.</p><p>At runtime, multiple plugins will be active at the same time. It is up to the Deployit core to integrate the various plugins and ensure they work together to perform deployments. A well-defined process (described below) is used to invoke all plugins involved in a deployment and turn their contributions into one consistent deployment plan. The execution of the deployment plan is handled by the Deployit core.</p><p>Plugins can define the following items:</p>
<ul>
  <li><em>deployable</em> Configuration Items (CIs) that are part of a package and that can be deployed</li>
  <li><em>container</em> CIs that are part of an environment and that can be deployed to</li>
  <li><em>deployed</em> CIs that represent the end result of the deployment of a deployable CI to a container CI</li>
  <li>a recipe describing how to deploy deployable CIs to container CIs</li>
</ul><p>These concepts are captured in Java interfaces that can be used to write plugins. See the section on "Writing a plugin in Java" below.</p><h2>Preparing and Performing Deployments in Deployit</h2><p>Performing a deployment in Deployit consists of a number of stages that, together, ensure that the deployment package is deployed and configured on the environment. Some of these activities are performed by the Deployit core, while others are performed by the plugins. This is the list of stages:</p>
<ul>
  <li><em>Specification</em>: create a <em>deployment specification</em> that defines which deployables (deployment package members) are to be deployed to which containers (environment members) and how they should be configured.</li>
  <li><em>Delta Analysis</em>: analyze the differences between the deployment specification and the current state of the middleware resulting in a <em>delta specification</em>, a list of delta's that describe changes to the middleware state that transform the current situation into the situation described by the deployment specification. The delta's represent operations needed on the deployment's members: <em>CREATE</em> when deploying a member for the first time, <em>MODIFY</em> when upgrading a member, <em>DESTROY</em> when undeploying a member and <em>NOOP</em> when there is no change.</li>
  <li><em>Orchestration</em>: split the delta specification into independent sub-specifications that can be planned and executed in isolation. Create a <em>deployment plan</em> containing nested <em>sub-plans</em>, a combination of a sub-specification and a list of <em>steps</em> needed to execute the sub-specification.</li>
  <li><em>Planning</em>: add <em>steps</em> to each sub-plan that, when executed, perform the actions needed to execute the actual deployment.</li>
  <li><em>Execution</em>: execute the complete deployment plan to perform the deployment.</li>
</ul><h2>Deployments and Plugins</h2><p>The following diagram depicts the way in which a plugin is involved in a deployment:</p><p><img src="images/Deployment-full.png"  alt="Deployment"/></p><p>On each of the arrows, you see a term from the previous section. Those transitions that are covered by a puzzle-piece are the ones that interact with the plugins, whereas the deployit-logo indicates that the transition is handled by the Deployit core.</p><p>The following sections describe how plugins are involved in the above mentioned activities. To clarify the description below, we will use a sample deployment of a deployment package for application PetClinic version 1.0, containing an EAR file, a datasource and static content, to an environment containing an Apache webserver and WebSphere application server.</p><p>Because the plugin is involved in the Specification and Planning stages, these will be detailed below.</p><h3>Specification</h3><p>In the Specification stage, the deployment to be executed is specified. This includes selecting the deployment package and members to be deployed, as well as mapping each package member to the environment members that they should be deployed to.</p><h4>Specifying CIs</h4><p>The plugin defines which CIs the Deployit core can use to create deployments. When a plugin is loaded into the Deployit core, Deployit scans the plugin for CIs and adds these to it's CI registry. Based on the CI information in the plugin, Deployit will categorize each CI as either a deployable CI (defining the <em>what</em> of the deployment) or a container CI (defining the <em>where</em> of the deployment).</p><h4>Specifying Relationships</h4><p>Where the deployable CI represents the passive resource or artifact, the deployed CI represents the <em>active</em> version of the deployable CI when it has been deployed in a container. By defining deployed CIs, the plugin indicates which combinations of deployable and container are supported.</p><h4>Configuration</h4><p>Each deployed CI represents a combination of a deployable CI and a container CI. It is important to note that one deployable CI can be deployed to multiple container CIs. For instance, an EAR file can be deployed to two application servers. In a deployment, this is modeled as multiple deployed CIs.</p><p>Sometimes it is desirable to configure a deployable CI differently depending on the container CI or environment it is deployed to. This can be done by configuring the properties of the deployed CI differently.</p><p>Configuring the deployed CIs is handled in the Deployit core. Users perform this task either via the GUI or via the CLI. The plugin can influence this process by providing default values for it's properties.</p><h4>Result</h4><p>The result of the Specification stage is a deployment specification, containing deployed CIs which describe which deployable CIs are mapped to which container CIs with the needed configuration.</p><h3>Planning</h3><p>In the Planning stage, the deployment specification and its resulting sub-plans that were created in the Orchestration stage are processed.</p><p>During this stage, the Deployit core performs the following procedure:</p>
<ul>
  <li>Preprocessing</li>
  <li>Contributor processing</li>
  <li>Postprocessing</li>
</ul><p>During each part of this procedure, the plugin is invoked so it can contribute (add) required deployment steps to the sub-plan.</p><h4>Preprocessing</h4><p>Preprocessing allows the plugin to contribute steps to the very beginning of the plan. During preprocessing, all <em>preprocessors</em> defined in the plugin are invoked in turn. Each preprocessor has full access to the delta specification. As such, the preprocessor can contribute steps based on the entire deployment. Examples of such steps are sending an email before starting the deployment or performing a pre-flight check on some CIs that are part of the deployment.</p><h4>Deployed CI processing</h4><p>In typical OO fashion, deployed CIs contain both the data and the behavior to make a deployment happen. Each of the deployed CIs that are part of the deployment can contribute steps to ensure that they are deployed or configured correctly.</p><p>Steps in a deployment plan must be specified in the correct order for the deployment to succeed. Furthermore, the order of these steps must be coordinated among an unknown number of plugins. To achieve this, Deployit weaves all the separate resulting steps from all the plugins by looking at their specified ordering.</p><p>For example, suppose we have a container CI representing a WAS application server called WasServer. This CI contains the data describing a WAS server (things like host, application directory, etc.) as well as the behavior to manage it. During a deployment to this WasServer, the WasServer CI contributes steps with order 10 to stop the WasServer. Also, it would contribute steps with order 90 to restart it. In the same deployment, a deployable CI called WasEar (representing the WAS EAR file) contributes steps to install itself with order 40. The resulting plan would weave the install of the EAR file (40) in between the stop (10) and start (90) steps.</p><p>This mechanism allows steps (behavior) to be packaged together with the CIs that contribute them. Also, CIs defined by separate plugins can work together to produce a well-ordered plan.</p><p>Even though a step can be registered with a specific order, Deployit uses the following default orders:</p>
<ul>
  <li>PRE_FLIGHT (<strong>0</strong>)</li>
  <li>STOP_ARTIFACTS (<strong>10</strong>)</li>
  <li>STOP_CONTAINERS (<strong>20</strong>)</li>
  <li>UNDEPLOY_ARTIFACTS (<strong>30</strong>)</li>
  <li>DESTROY_RESOURCES (<strong>40</strong>)</li>
  <li>CREATE_RESOURCES (<strong>60</strong>)</li>
  <li>DEPLOY_ARTIFACTS (<strong>70</strong>)</li>
  <li>START_CONTAINERS (<strong>80</strong>)</li>
  <li>START_ARTIFACTS (<strong>90</strong>)</li>
  <li>POST_FLIGHT (<strong>100</strong>)</li>
</ul><h4>Postprocessing</h4><p>Postprocessing is similar to preprocessing, but allows a plugin to add one or more steps to the very end of a plan. A postprocessor could for instance add a step to send a mail once the deployment has been completed.</p><h4>Result</h4><p>The Planning stage results in a deployment plan that contains all steps necessary to perform the deployment. The deployment plan is ready to be executed.</p><p>This concludes the involvement of the plugin in the deployment planning process.</p><h2>Writing a plugin in Java</h2><p>When writing a plugin in Java, the following interfaces are used to represent the concepts outlined above:</p>
<ul>
  <li><em>Deployable</em> classes represent deployable CIs.</li>
  <li><em>Container</em> classes represent container CIs.</li>
  <li><em>Deployed</em> classes represent deployed CIs.</li>
</ul><p>In addition to these types, plugins also specify the behavior required to perform the deployment. That is, which actions (steps) are needed to ensure that a deployable ends up in the container as a deployed. In good OO-fashion, this behavior is part of the Deployed class.</p><p>Let's look at the mechanisms available to plugin writers in each of the two deployment phases, Specification and Planning.</p><h3>Specifying a Namespace</h3><p>All of the CIs in Deployit are part of a namespace to distinguish them from other, similarly named CIs. For instance, CIs that are part of the UDM plugin all use the <em>udm</em> namespace (such as <em>udm.Deployable</em>).</p><p>Plugins implemented in Java must specify their namespace in a source file called <em>package-info.java</em>. This file provides package-level annotations and is required to be in the same package as your CIs. </p><p>This is an example package-info file:</p>
<pre><code>@Prefix(&quot;yak&quot;)
package com.xebialabs.deployit.plugin.test.yak.ci;

import com.xebialabs.deployit.plugin.api.annotation.Prefix;
</code></pre><h3>Specification</h3><p>This section describes Java classes used in defining CIs that are used in the Specification stage.</p><h4>udm.ConfigurationItem and udm.BaseConfigurationItem</h4><p>The udm.BaseConfigurationItem is the base class for all the standard CIs in Deployit. It provides the <em>syntheticProperties</em> map and a default implementation for the name of a CI.</p><h4>udm.Deployable and udm.BaseDeployable</h4><p>The udm.BaseDeployable is the default base class for types that are deployable to <em>udm.Container</em> CIs. It does not add any additional behavior</p><h4>udm.Container and udm.BaseContainer</h4><p>The udm.BaseContainer is the default base class for types that can contain <em>udm.Deployable</em> CIs. It does not add any additional behavior</p><h4>udm.Deployed and udm.BaseDeployed</h4><p>The udm.BaseDeployed is the default base class for types that specify which <em>udm.Deployable</em> CI can be deployed onto which <em>udm.Container</em> CI. </p><h4>Additional UDM concepts</h4><p>Next to these base types, the UDM defines a number of implementations with higher level concepts that facilitate deployments.</p>
<ul>
  <li><strong>udm.Environment</strong>: The Environment is the target for a deployment in Deployit. It has members of type <em>udm.Container</em></li>
  <li><strong>udm.Application</strong>: The Application is a grouping of multiple <em>udm.DeploymentPackage</em> CIs that can each be the source of a deployment (for example: application = PetClinic; version = 1.0, 2.0, ...)</li>
  <li><strong>udm.DeploymentPackage</strong>: A deployment package has a set of <em>udm.Deployable</em> CIs, and it is the source for a deployment in Deployit.</li>
  <li><strong>udm.DeployedApplication</strong>: The DeployedApplication resembles the deployment of a _udm.DeploymentPackage to a <em>udm.Environment</em> with a number of specific <em>udm.Deployed</em> CIs</li>
  <li><strong>udm.Artifact</strong>: An implementation of a <em>udm.Deployable</em> which resembles a 'physical' artifact on disk (or memory)</li>
  <li><strong>udm.FileArtifact</strong>: A <em>udm.Artifact</em> which points to a single file</li>
  <li><strong>udm.FolderArtifact</strong>: A <em>udm.Artifact</em> which points to a directory structure</li>
</ul><h3>Mapping Deployables to Containers</h3><p>When creating a deployment, the deployables in the package are targeted to one or more containers. The deployable on the container is represented as a deployed. Deployeds are defined by the deployable CI type and container CI type they support. Registering a deployed CI in Deployit informs the system that the combination of the deployable and container is possible and how it is to be configured. Once such a CI exists, Deployit users can create them in the GUI by dragging the deployable to the container.</p><h3>Planning</h3><p>During planning a plugin can contribute steps to the deployment plan. Each of the mechanisms that can be used is described below</p><h4>@PrePlanProcessor and @PostPlanProcessor</h4><p>The @PrePlanProcessor and @PostPlanProcessor annotations can be specified on a method to define a pre- or postprocessor. The pre- or postprocessor takes an optional order attribute which defaults to '100'; lower order means it is earlier, higher order means it is later in the processor chain. The method should take a <em>DeltaSpecification</em> and return either a <em>Step</em> or <em>List of Step</em>, the name can be anything, so you can define multiple pre- and postprocessors in one class. See these examples:</p>
<pre><code>@PrePlanProcessor
public Step preProcess(DeltaSpecification specification) { ... }

@PrePlanProcessor
public List&lt;Step&gt; foo(DeltaSpecification specification) { ... }

@PostPlanProcessor
public Step postProcess(DeltaSpecification specification) { ... }

@PostPlanProcessor
public List&lt;Step&gt; bar(DeltaSpecification specification) { ... }
</code></pre><p>As a pre- or postprocessor is instantiated when it is needed, it should have a default constructor. Any fields on the class are not set, so the annotated method should not rely on them being set.</p><h4>@Create, @Modify, @Destroy, @Noop</h4><p>Deployeds can contribute steps to a deployment in which it is present. The methods that are invoked should also be specified in the <em>udm.Deployed</em> CI. It should take a DeploymentPlanningContext, to which one or more Steps can be added with specific ordering. The return type of the method should be <em>void</em>.</p><p>The method is annotated with the operation that is currently being performed on the Deployed CI. See the following example, the method createEar is called for both a <em>create</em> and a <em>modify</em> of the DeployedWasEar.</p>
<pre><code>public class DeployedWasEar extends BaseDeployed&lt;Ear, WasServer&gt; {
    ...

    @Create @Modify
    public void createEar(DeploymentPlanningContext context) {
       // do something with my field and add my steps to the result
       // for a particular order
       context.addStep(40, new CreateEarStep(this));
    }
}
</code></pre><h4>@Contributor</h4><p>A @Contributor contributes steps for the set of _Delta_s in the current sub-plan being evaluated. The methods annotated with @Contributor can be present on any Java class which has a default constructor. The generated steps should be added to the collector argument <em>context</em>.</p>
<pre><code>@Contributor
public void contribute(Deltas deltas, DeploymentPlanningContext context) { ... }
</code></pre><h2>Packaging your plugin</h2><p>Plugins are distributed as standard Java ARchives (JARs). These JARs can be added to the Deployit server <em>plugins</em> directory which is added to the Deployit server classpath when it boots. Deployit will scan it's classpath for plugin CIs and load these into it's registry. The CIs are used and invoked during a deployment when appropriate.</p><p>Synthetic extension files packaged in the JAR file will be found and read. If there are multiple extension files present, they will be combined and the changes from all files will be combined.</p><h1>Appendices</h1><h2>Synthetic XSD</h2><p>This is the schema of the <em>synthetic.xml</em> file used to contribute types and type changes to Deployit.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
       xmlns=&quot;http://www.xebialabs.com/deployit/synthetic&quot;
       targetNamespace=&quot;http://www.xebialabs.com/deployit/synthetic&quot;
       elementFormDefault=&quot;qualified&quot;&gt;

    &lt;xs:element name=&quot;synthetic&quot;&gt;
        &lt;xs:complexType&gt;
            &lt;xs:choice maxOccurs=&quot;unbounded&quot;&gt;
                &lt;xs:element name=&quot;type&quot; type=&quot;SyntheticTypeDefinition&quot;/&gt;
                &lt;xs:element name=&quot;type-modification&quot; type=&quot;SyntheticTypeModification&quot;/&gt;
            &lt;/xs:choice&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:complexType name=&quot;SyntheticTypeDefinition&quot;&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;generate-deployable&quot; type=&quot;SyntheticDeployableGeneration&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
            &lt;xs:element name=&quot;property&quot; type=&quot;SyntheticPropertyDefinition&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name=&quot;type&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;extends&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;virtual&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;deployable-type&quot; type=&quot;DeployitTypeName&quot;/&gt;
        &lt;xs:attribute name=&quot;container-type&quot; type=&quot;DeployitTypeName&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticDeployableGeneration&quot;&gt;
        &lt;xs:attribute name=&quot;type&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;extends&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticTypeModification&quot;&gt;
        &lt;xs:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
            &lt;xs:element name=&quot;property&quot; type=&quot;SyntheticPropertyDefinition&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name=&quot;type&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticPropertyDefinition&quot;&gt;
        &lt;xs:attribute name=&quot;name&quot; type=&quot;JavaPropertyName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;kind&quot; type=&quot;KindType&quot;/&gt;
        &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;category&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;label&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;required&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;password&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;size&quot; type=&quot;SizeType&quot;/&gt;
        &lt;xs:attribute name=&quot;default&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;enum-class&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;referenced-type&quot; type=&quot;DeployitTypeName&quot;/&gt;
        &lt;xs:attribute name=&quot;as-containment&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;hidden&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;transient&quot; type=&quot;xs:boolean&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:simpleType name=&quot;JavaPropertyName&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:pattern value=&quot;[a-zA-Z0-9_]*&quot;/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:simpleType name=&quot;DeployitTypeName&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:pattern value=&quot;[a-zA-Z0-9-]*\.[a-zA-Z0-9-]*&quot;/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:simpleType name=&quot;KindType&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:enumeration value=&quot;enum&quot;/&gt;
            &lt;xs:enumeration value=&quot;boolean&quot;/&gt;
            &lt;xs:enumeration value=&quot;integer&quot;/&gt;
            &lt;xs:enumeration value=&quot;string&quot;/&gt;
            &lt;xs:enumeration value=&quot;ci&quot;/&gt;
            &lt;xs:enumeration value=&quot;set_of_ci&quot;/&gt;
            &lt;xs:enumeration value=&quot;set_of_string&quot;/&gt;
            &lt;xs:enumeration value=&quot;map_string_string&quot; /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:simpleType name=&quot;SizeType&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:enumeration value=&quot;default&quot;/&gt;
            &lt;xs:enumeration value=&quot;small&quot;/&gt;
            &lt;xs:enumeration value=&quot;medium&quot;/&gt;
            &lt;xs:enumeration value=&quot;large&quot;/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</code></pre><h2>Sample Java Plugin</h2><p>The following are some sample classes from a test plugin we use, the Yak plugin.</p><p>When discussing the plugin, let's use a sample deployment:</p>
<ul>
  <li>a deployment package containing version 1.1 of the YakApp application.</li>
  <li>the application contains two deployable CIs, "yakfile1" and "yakfile2", both of type <em>YakFile</em>.</li>
  <li>an environment containing a container CI, "yakserver", of type <em>YakServer</em>.</li>
  <li>an older version of the application, YakApp/1.0 is already deployed on the container.</li>
  <li>YakApp/1.0 contains an older version of yakfile1, but yakfile2 is new in this deployment.</li>
</ul><h3>Deployable: YakFile</h3><p>The <em>YakFile</em> is a deployable CI representing a file artifact. It extends the built-in <em>FileArtifact</em> class.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.ci;

import com.xebialabs.deployit.plugin.api.udm.FileArtifact;

public class YakFile extends FileArtifact {
}
</code></pre><p>In our sample deployment, both yakfile1 and yakfile2 are instances of this Java class.</p><h3>Container: YakServer</h3><p>The <em>YakServer</em> is a container that, when included in an environment, can be the target of a deployment.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.ci;

// imports omitted...

@Metadata(root = Metadata.ConfigurationItemRoot.INFRASTRUCTURE)
public class YakServer extends BaseContainer {

    @Contributor
    public void stopYak(Deltas deltas, DeploymentPlanningResult result) {
        logger.debug(&quot;Stopping Yak server&quot;);
        result.addStep(20, new StopYakServerStep(this));
    }

    @Contributor
    public void startYaks(Deltas deltas, DeploymentPlanningResult result) {
        logger.debug(&quot;Starting all Yak servers&quot;);
        Set&lt;YakServer&gt; yakServers = gatherYakServers(deltas.getDeltas());
        for (YakServer yakServer : yakServers) {
            result.addStep(90, new StartYakServerStep(yakServer));
        }
    }

    private Set&lt;YakServer&gt; gatherYakServers(List&lt;Delta&gt; operations) {
        Set&lt;YakServer&gt; servers = new TreeSet&lt;YakServer&gt;();
        for (Delta operation : operations) {
            if (operation.getDeployed() instanceof RestartRequiringDeployedYakFile &amp;&amp; 
          operation.getDeployed().getContainer() instanceof YakServer) {
                servers.add((YakServer) operation.getDeployed().getContainer());
            }
        }
        return servers;
    }

    private static final Logger logger = LoggerFactory.getLogger(YakServer.class);
}
</code></pre><p>This class shows several interesting features:</p>
<ul>
  <li>the YakServer extends the built-in <em>BaseContainer</em> class.</li>
  <li>the @Metadata annotation specifies where in the Deployit repository the CI will be stored. In this case, the CI will be stored under the Infrastructure node. (see the Deployit Reference Manual for more information on the repository).</li>
  <li>the <em>stopYak</em> method annotated with @ContainerContributor is invoked when the YakServer is part of an environment that is being deployed to. The method receives the deltas of the current sub-specification and can contribute steps to the resulting plan.</li>
  <li>the <em>startYaks</em> method shows another way to contribute steps to a plan. In this case, the method is annotated with the @Contributor annotation, causing it to be invoked when any deployment takes place (also deployments that may not necessarily contain an instance of the YakServer class). The method searches for any YakServer instances that are present in the deployment and that require a restart. For each of these YakServer instances, a <em>StartYakServerStep</em> (see below) is added to the plan.</li>
</ul><p>In our sample deployment, the "yakserver" CI is part of the deployment, so the <em>stopYak</em> method is invoked when planning the deployment. When the <em>startYaks</em> method is invoked, the <em>deltas</em> parameter contains operations for both yakfile CIs. If either of the yakfile CIs was an instance of <em>RestartRequiringDeployedYakFile</em>, a start step would be added to the deployment plan.</p><h3>Deployed: DeployedYakFile</h3><p>The <em>DeployedYakFile</em> represents a <em>YakFile</em> deployed to a <em>YakServer</em>, as reflected in the class definition. The class extends the built-in <em>BaseDeployed</em> class.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.ci;

// imports omitted...

public class DeployedYakFile extends BaseDeployed&lt;YakFile, YakServer&gt; {

    @Modify @Destroy
    public void stop(DeploymentPlanningResult result) {
        result.addStep(10, new StopDeployedYakFileStep(this));
    }

    @Create @Modify
    public void start(DeploymentPlanningResult result) {
        logger.info(&quot;Adding start artifact&quot;);
        result.addStep(90, new StartDeployedYakFileStep(this));
    }

    @Create
    public void deploy(DeploymentPlanningResult result) {
        logger.info(&quot;Adding step&quot;);
        result.addStep(70, new DeployYakFileToServerStep(this));
    }

    @Modify
    public void upgrade(DeploymentPlanningResult result) {
        logger.info(&quot;Adding upgrade step&quot;);
        result.addStep(70, new UpgradeYakFileOnServerStep(this));
    }

    @Destroy
    public void destroy(DeploymentPlanningResult result) {
        logger.info(&quot;Adding undeploy step&quot;);
        result.addStep(30, new DeleteYakFileFromServerStep(this));
    }

    private static final Logger logger = LoggerFactory.getLogger(DeployedYakFile.class);
}
</code></pre><p>This class shows how to use the @DeployedContributor to contribute steps to a deployment that includes this particular, configured instance of the DeployedYakFile. Each method annotated with the @DeployedContributor annotation is invoked when the specified operation is present in the deployment for the YakFile.</p><p>In our sample deployment, yakfile1 already exists on the target container CI so a <em>MODIFY</em> delta will be present in the delta specification for this CI, causing the <em>stop</em>, <em>start</em> and <em>upgrade</em> methods to be invoked on the CI instance. Because yakfile2 is new, a <em>CREATE</em> delta will be present, causing the <em>start</em>, and <em>deploy</em> method to be invoked on the CI instance.</p><h3>Step: StartYakServerStep</h3><p>Steps are the actions that will be executed when the deployment plan is started. Below is a sample step above.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.step;

// imports omitted...

public class StartYakServerStep implements Step {

    private YakServer server;

    public StartYakServerStep(YakServer server) {
        this.server = server;
    }

    @Override
    public String getDescription() {
        return &quot;Starting &quot; + server;
    }

    @Override
    public Result execute(StepExecutionContext ctx) throws Exception {
        return Step.Result.Success;
    }

    public YakServer getServer() {
        return server;
    }
}
</code></pre></body></html>