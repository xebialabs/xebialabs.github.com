<html><head><LINK REL=StyleSheet HREF="css/deployit.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="css/ci-reference-api.css" TYPE="text/css" MEDIA=screen>
<script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
<script type="text/javascript" src="js/jquery.tableofcontents.min.js"></script>
<script type="text/javascript" charset="utf-8">
$(document).ready(function(){
    $("body").attr('id', 'top-toc');
    var title = $("<div class='manual-title'/>")
    title.html("<div class='title'>Customization Manual</div><div class='version'>Version <span class='version-number'>3.6.2-SNAPSHOT</span></div>");
    $("body").css('width', '100%');
    $("body").prepend(title);
    $("body").prepend($("<ol id='toc'/>"));
    $("#toc").tableOfContents("body", { topLinks: true, } );
});

</script>
<title>Customization Manual</title>
</head><body><h1>Introduction</h1><p>This manual describes how to customize Deployit for use in your environment.</p><p>Out-of-the-box, Deployit provides deployment capabilities for several middleware platforms. However, at times we need to integrate Deployit with certain environments or deploy to middleware stacks that Deployit does not readily support. Tailoring deployment plans, adding support for new middleware and integrating with other systems are all possible by customizing the Deployit system. This manual describes what customizations are possible and how to adapt Deployit to fit into your environment.</p><p>This manual will first give an overview of the different ways of customizing Deployit. Then, Deployit system architecture is described to show the role of Deployit extensions and plugins in the deployment process. Finally, we show how to add custom Deployit plugins.</p><h1>Customization Overview</h1><p>Deployit is designed with extensibility in mind and provides several different ways to modify its behavior. Depending on the extender's skill set and requirements, one or more of these methods can be used to achieve the desired result.</p><p>There are four ways to customize Deployit.</p>
<ol>
  <li>Adding or modifying configuration items (CIs) by customizing the Deployit type system</li>
  <li>Adding or modifying CI behavior by customizing one of the plugins provided by XebiaLabs</li>
  <li>Adding Deployit Server functionality by providing server plugpoint implementations</li>
  <li>Adding custom CIs and deployment functionality by writing a new plugin</li>
</ol><p>Each of these types of customizations are described in the remainder of this document.</p><h1>Customizing the Deployit Type System</h1><p>Today's middleware products are complicated and support lots of configuration options. Deployit plugins represent this middleware to the Deployit system. If a plugin wants to be a direct representation of the options in the middleware, it will quickly grow very large and unwieldy. Deployit provides a better way.</p><p>Given a CI defined in a plugin, an extender can customize this CI by adding new <em>synthetic properties</em> to the Java class, or by using the type system to extend the CI. These additions can either be done using plain Java, or by defining them in an XML file called <em>synthetic.xml</em> which can be added to the Deployit classpath. Changes to the types are loaded when the Deployit server starts and can be used to perform deployments.</p><h2>Modifying Existing CIs</h2><p>Types existing in Deployit can be modified to contain additional <em>synthetic properties</em>. These properties become a part of the CI type and can be specified in the deployment package and shown in the Deployit GUI.</p><p>There are several reasons to modify:</p>
<ul>
  <li>A CI property is always given the same value in your environment. Using synthetic properties, the property can be given a default value and hidden from the user in the GUI.</li>
  <li>There are additional properties of an existing CI that you want to specify. For example, suppose there is a CI representing a deployed datasource for a specific middleware platform. The middleware platform allows the user to specify a connection pool size and connection timeout and Deployit supports the connection pool size out of the box. In this case, modifying the CI to add a synthetic property allows the user to specify the connection timeout. <strong>Note that this new synthetic property still needs to be communicated to the target middleware platform by the plugin. Consult the plugin manual in question to ensure the new property and its value are passed to the target middleware.</strong></li>
</ul><p>The following information can be specified when modifying a CI:</p>
<table class="deployed-matrix">
	<tr>
		<th>Property</th>
		<th>Required</th>
		<th>Meaning</th>
	</tr>
	<tr>
		<td>type</td>
		<td>Yes</td>
		<td>Specifies the CI type to modify</td>
	</tr>
</table><p>Additionally, any property that is modified is listed as a nested <code>property</code> element. For each property, the following information can be specified:</p>
<table class="deployed-matrix">
	<tr>
		<th>Property</th>
		<th>Required</th>
		<th>Meaning</th>
	</tr>
	<tr>
		<td>name</td>
		<td>Yes</td>
		<td>The name of the property to modify</td>
	</tr>
	<tr>
		<td>kind</td>
		<td>No</td>
		<td>The type of the property to modify. Possible values are: enum, boolean, integer, string, ci, set_of_ci, set_of_string, map_string_string</td>
	</tr>
	<tr>
		<td>description</td>
		<td>No</td>
		<td>Describes the property</td>
	</tr>
	<tr>
		<td>category</td>
		<td>No</td>
		<td>Categorizes the property. Each category is shown in a separate tab in the Deployit GUI</td>
	</tr>
	<tr>
		<td>label</td>
		<td>No</td>
		<td>Sets the property's label. If set, the label is shown in the Deployit GUI instead of the name</td>
	</tr>
	<tr>
		<td>required</td>
		<td>No</td>
		<td>Indicates whether the property is required or not</td>
	</tr>
	<tr>
		<td>password</td>
		<td>No</td>
		<td>Indicates whether the property stores a password. If so, the property value is encrypted in the Deployit GUI and CLI</td>
	</tr>
	<tr>
		<td>size</td>
		<td>No</td>
		<td><i>Only relevant for properties of kind <b>string</b>.</i> Specifies the property size. Possible values are: default, small, medium, large. Large text fields will be shown as a textarea in the Deployit GUI</td>
	</tr>
	<tr>
		<td>default</td>
		<td>No</td>
		<td>Specifies the default value of the property</td>
	</tr>
	<tr>
		<td>enum-class</td>
		<td>No</td>
		<td><i>Only relevant for properties of kind <b>enum</b>.</i> The  enumeration class that contains the possible values for this property</td>
	</tr>
	<tr>
		<td>referenced-type</td>
		<td>No</td>
		<td><i>Only relevant for properties of kind <b>ci</b> or <b>set_of_ci</b>.</i> The type of the referenced CI.</td>
	</tr>
	<tr>
		<td>as-containment</td>
		<td>No</td>
		<td><i>Only relevant for properties of kind <b>ci</b> or <b>set_of_ci</b>.</i> Indicates whether the property is modeled as containment in the repository. If true, the referenced CI or CIs are stored under the CI</td>
	</tr>
	<tr>
		<td>hidden</td>
		<td>No</td>
		<td>Indicates whether the property is hidden. Hidden properties don't show up in the Deployit GUI. Note that a hidden property must have a default value</td>
	</tr>
	<tr>
		<td>transient</td>
		<td>No</td>
		<td>Indicates whether the property is persisted in the repository or not</td>
	</tr>
</table><p>See the appendix for the full XSD of this format as used in the file <code>synthetic.xml</code>.</p><p>Here are some examples of modifying a CI.</p><h3>Hiding a CI Property</h3><p>The following XML snippet hides the <code>connectionTimeoutMillis</code> property for <code>Hosts</code> from the UI and gives it a default value:</p>
<pre><code>&lt;type-modification type=&quot;base.Host&quot;&gt;
    &lt;property name=&quot;connectionTimeoutMillis&quot; kind=&quot;integer&quot; default=&quot;1200000&quot; hidden=&quot;true&quot; /&gt;
&lt;/type-modification&gt;
</code></pre><h3>Extending a CI</h3><p>For example, you could add a notes field to a CI to record notes:</p>
<pre><code>&lt;type-modification type=&quot;overthere.Host&quot;&gt;
    &lt;property name=&quot;notes&quot; kind=&quot;string&quot;/&gt;
&lt;/type-modification&gt;
</code></pre><h2>Defining new CIs</h2><p>It is also possible to define new CIs using this mechanism. By specifying a new type, its base (either a concrete Java class or another synthetic type) and namespace, a new type will become available in Deployit. This means the CI type can be a part of deployment packages and created in the Repository browser. Each of the three categories of CIs (deployables, deployeds and containers) can be defined this way. </p><p>The following information can be specified when defining a new type:</p>
<table class="deployed-matrix">
	<tr>
		<th>Property</th>
		<th>Required</th>
		<th>Meaning</th>
	</tr>
	<tr>
		<td>type</td>
		<td>Yes</td>
		<td>The CI type name</td>
	</tr>
	<tr>
		<td>extends</td>
		<td>Yes</td>
		<td>The parent CI type that this CI type inherits from</td>
	</tr>
	<tr>
		<td>description</td>
		<td>No</td>
		<td>Describes the new CI</td>
	</tr>
	<tr>
		<td>virtual</td>
		<td>No</td>
		<td>Indicates whether the CI is virtual (used to group together common properties) or not. Virtual CIs can not be used in a deployment package</td>
	</tr>
	<tr>
		<td>deployable-type</td>
		<td>No</td>
		<td><i>Only relevant for deployed CIs.</i> The type of deployable CI type that this CI type deploys</td>
	</tr>
	<tr>
		<td>container-type</td>
		<td>No</td>
		<td><i>Only relevant for deployed CIs.</i> The type of CI container that this CI type is deployed to</td>
	</tr>
	<tr>
		<td>generate-deployable</td>
		<td>No</td>
		<td><i>Only relevant for deployed CIs.</i> The type of deployable CI to be generated. This property is specified as a nested element</td>
	</tr>
</table><p>For each defined CI, zero or more properties can be specified. See the section above for more information.</p><p>Here is an example for each of the CI categories.</p><h3>Defining a Deployable CI</h3><p>Usually, deployable CIs are generated by Deployit (see the <code>generate-deployable</code> element above). The following snippet shows an example of defining a deployable manually:</p>
<pre><code>&lt;type type=&quot;acme.CustomWar&quot; extends=&quot;jee.War&quot;&gt;
    &lt;property name=&quot;startApplication&quot; kind=&quot;boolean&quot; required=&quot;true&quot;/&gt;
&lt;/type&gt;
</code></pre><h3>Defining a Container CI</h3><p>This XML snippet shows how to define a new container CI:</p>
<pre><code>&lt;type type=&quot;tc.Server&quot; extends=&quot;generic.Container&quot;&gt;
    &lt;property name=&quot;home&quot; default=&quot;/tmp/tomcat&quot;/&gt;
&lt;/type&gt;
</code></pre><h3>Defining a Deployed CI</h3><p>This XML snippet shows how to define a new deployed CI:</p>
<pre><code>&lt;type type=&quot;tc.WarModule&quot; extends=&quot;udm.BaseDeployedArtifact&quot; deployable-type=&quot;jee.War&quot;
      container-type=&quot;tc.Server&quot;&gt;
    &lt;generate-deployable type=&quot;tc.War&quot; extends=&quot;jee.War&quot;/&gt;
    &lt;property name=&quot;changeTicketNumber&quot; required=&quot;true&quot;/&gt;
    &lt;property name=&quot;startWeight&quot; default=&quot;1&quot; hidden=&quot;true&quot;/&gt;
&lt;/type&gt;
</code></pre><p>The <em>tc.WarModule</em> CI is generated when a <em>tc.War</em> is deployed to a <em>tc.Server</em>. The new CI inherits all properties from the <em>udm.BaseDeployedArtifact</em> CI and adds the required property <code>changeTicketNumber</code>. The <code>startWeight</code> property is hidden from the user with a default value of 1.</p><h2>Defining Synthetic Methods</h2><p>In addition to defining CIs, it is also possible to define <em>methods</em> on CIs. Each method can be executed on an instance of a CI via the GUI or CLI. Methods are used to implement <em>control tasks</em>, actions on CIs to control the middleware. An example is start or stopping of a server. The CI itself is responsible for implementing the specified method. </p><p>This XML snippet shows how to define a control task:</p>
<pre><code>&lt;type type=&quot;tc.DeployedDataSource&quot; extends=&quot;generic.ProcessedTemplate&quot; deployable-type=&quot;tc.DataSource&quot;
      container-type=&quot;tc.Server&quot;&gt;
    &lt;generate-deployable type=&quot;tc.DataSource&quot; extends=&quot;generic.Resource&quot;/&gt;
    ...
    &lt;method name=&quot;ping&quot; description=&quot;Test whether the datasource is available&quot;/&gt;
&lt;/type&gt;
</code></pre><p>The <em>ping</em> method defined above can be invoked on an instance of the <em>tc.DeployedDataSource</em> CI through the server REST interface, GUI or CLI. The implementation of the <em>ping</em> method is part of the <em>tc.DeployedDataSource</em> CI.</p><h2>Defining Validation Rules</h2><p>It is possible to add validation rules to properties and CIs in the synthetic.xml. Out of the box, Deployit comes with the <em>regex</em> validation rule, which can be used to define naming conventions using regular expressions.</p><p>This XML snippet shows how to add a validation rule:</p>
<pre><code>&lt;type type=&quot;tc.WarModule&quot; extends=&quot;ud.BaseDeployedArtifact&quot; deployable-type=&quot;jee.War&quot;
       container-type=&quot;tc.Server&quot;&gt;
    &lt;property name=&quot;changeTicketNumber&quot; required=&quot;true&quot;&gt;
        &lt;validation type=&quot;regex&quot; regex=&quot;^JIRA-[0-9]+$&quot; /&gt;
    &lt;/property&gt;
&lt;/type&gt;
</code></pre><p>The validation will throw an error, when the <em>tc.WarModule</em> is being saved in Deployit with a value that is not of the form <code>JIRA-number</code>.</p><h1>Customizing Provided Plugins</h1><p>Using the type system, the Deployit plugins provided by XebiaLabs can be customized. New CI properties or scripts can be added to supplement the functionality delivered by the plugin. More information about this can be found in the respective plugin manuals.</p><h1>Customizing Deployit Server using Plugpoints</h1><p>Functionality in the Deployit Server can be customized by using <em>plugpoints</em>. Plugpoints are specified and implemented in Java. On startup, Deployit scans its classpath for implementations of its plugpoints in the <em>com.xebialabs</em> or <em>ext.deployit</em> packages and prepares them for use. There is no additional configuration required.</p><p>The Deployit Server supports the following plugpoints:</p>
<ul>
  <li><em>protocol</em>: specify a new method for connecting to remote hosts</li>
  <li><em>deployment package importer</em>: allow Deployit to import deployment packages in a custom format</li>
</ul><h2>Defining Protocols</h2><p>A protocol in Deployit is a method for making a connection to a host. <em>Overthere</em>, Deployit's remote execution framework, uses protocols to build a connection with a target machine. Protocol implementations are read by Overthere when Deployit starts.</p><p>Classes implementing a protocol must adhere to two requirements:</p>
<ul>
  <li>the class must implement the <em>OverthereConnectionBuilder</em> interface</li>
  <li>the class must have the <em>@Protocol</em> annotiation</li>
</ul><p>The <em>OverthereConnectionBuilder</em> interface specifies only one method, <em>connect</em>. This method creates and returns a subclass of <em>OverthereConnection</em> representing a connection to the remote host. The connection must provide access to files (<em>OverthereFile</em> instances) that Deployit uses to execute deployments.</p><p>For more information, see the <a href="http://github.com/xebialabs/overthere">Overthere project</a>.</p><h2>Defining Importers and ImportSources</h2><p>An <em>importer</em> is a class that turns a source into a collection of Deployit entities. Both the import source as well as the importer can be customized. Deployit comes with a default importer that understands the DAR package format (see the <strong>Packaging Manual</strong> for details).</p><p>Import sources are classes implementing the <em>ImportSource</em> interface and can be used to obtain a handle to the deployment package file to import. Import sources can also implement the <em>ListableImporter</em> interface, which indicates they can produce a list of possible files that can be imported. The user can make a selection out of these options to start the import process.</p><p>When the import source has been selected, all configured importers in Deployit are invoked in turn to see if any importer is capable of handling the selected import source (the <em>canHandle</em> method). The first importer that indicates it can handle the package is used to perform the import. Deployit's default importer is used as a fallback.</p><p>First, the <em>preparePackage</em> method is invoked. This instructs the importer to produce a <em>PackageInfo</em> instance describing the package metadata. This data is used by Deployit to determine whether the user requesting the import has sufficient rights to perform it. If so, the importer's <em>importEntities</em> method is invoked, allowing the importer to read the import source, create deployables from the package and return a complete <em>ImportedPackage</em> instance. Deployit will handle storing of the package and contents.</p><h1>Writing a custom plugin</h1><p>Writing a custom plugin is the most powerful way to extend Deployit. It uses Deployit's Java plugin API which is also used by all of the plugins provided by XebiaLabs. The plugin API specifies a contract between Deployit core and a plugin that ensures that a plugin can safely contribute, along with other plugins, to the calculated deployment plan. To understand the plugin API, it is helpful to learn about the Deployit system architecture and how the plugins are involved in performing a deployment. The following sections provide this background information and are followed an explanation of how to build your own plugin.</p><h2>Deployit Architecture</h2><p>Deployit features a modular architecture that allows components to be changed and extended while maintaining a consistent system. The following diagram provides a high-level overview of the system architecture:</p><p><img src="images/deployit-architecture.png"  alt="Deployit Architecture"/></p><p>Deployit's central component is referred to as the <em>core</em> and contains the following functionality:</p>
<ul>
  <li>The Unified Deployment Engine which determines what is required to perform a deployment</li>
  <li>Storage and retrieval of deployment packages</li>
  <li>Executing and storing of deployment tasks</li>
  <li>Security</li>
  <li>Reporting</li>
</ul><p>The Deployit core is accessed using a REST service. The product ships with two clients of the REST service, a graphical user interface (GUI) built in Flex that runs in browsers using Flash, and a command-line interface (CLI) that interprets Jython.</p><p>Support for various middleware platforms is provided in the form of <em>Deployit plugins</em>. Deployit plugins add capabilities to Deployit and may be delivered by XebiaLabs or custom-built by users of Deployit. </p><h2>Deployit and Plugins</h2><p>A Deployit plugin is a component that provides the Deployit server with a way to interact with a specific piece of middleware. It allows the Deployit core to remain independent of the middleware it connects with. At the same time, it allows plugin writers to extend Deployit in a way that seamlessly integrates with the rest of Deployit's functionality. Existing Deployit plugins can be extended to customize Deployit for your environment. It's even possible to write a new Deployit plugin from scratch.</p><p>To integrate with the Deployit core, the plugins adhere to a well-defined interface. This interface specifies the contract between the Deployit plugin and the Deployit core, making it clear what each can expect of the other. The Deployit core is the active party in this collaboration and invokes the plugin whenever needed. For its part, the Deployit plugin replies to requests it is sent. When the Deployit server starts it scans the classpath and loads each Deployit plugin it finds, readying it for interaction with the Deployit core. The Deployit core does not change loaded plugins or load any new plugins after it has started.</p><p>At runtime, multiple plugins will be active at the same time. It is up to the Deployit core to integrate the various plugins and ensure they work together to perform deployments. There is a well-defined process (described below) that invokes all plugins involved in a deployment and turn their contributions into one consistent deployment plan. The execution of the deployment plan is handled by the Deployit core.</p><p>Plugins can define the following items:</p>
<ul>
  <li><em>Deployable</em> - Configuration Items (CIs) that are part of a package and that can be deployed</li>
  <li><em>Container</em> - CIs that are part of an environment and that can be deployed to</li>
  <li><em>Deployed</em> - CIs that represent the end result of the deployment of a deployable CI to a container CI</li>
  <li>A recipe describing how to deploy deployable CIs to container CIs</li>
  <li>Validation rules to validate CIs or properties of CIs</li>
</ul><p>These concepts are captured in Java interfaces that can be used to write plugins. See the section on "Writing a plugin in Java" below. First we will describe the steps that are involved when doing a deployment in Deployit.</p><h2>Preparing and Performing Deployments in Deployit</h2><p>Performing a deployment in Deployit consists of a number of stages that, together, ensure that the deployment package is deployed and configured on the environment. Some of these activities are performed by the Deployit core, while others are performed by the plugins. </p><p>This is the list of stages:</p>
<ul>
  <li><em>Specification</em>: This stage creates a <em>deployment specification</em> that defines which deployables (deployment package members) are to be deployed to which containers (environment members) and how they should be configured.</li>
  <li><em>Delta Analysis</em>: Analyzes the differences between the deployment specification and the current state of the middleware resulting in a <em>delta specification</em>, a list of deltas that describe changes to the middleware state that transform the current situation into the situation described by the deployment specification. The deltas represent operations needed on the deployment's members. There are four defined operations:
  <ul>
    <li>CREATE when deploying a member for the first time</li>
    <li>MODIFY when upgrading a member</li>
    <li>DESTROY when undeploying a member</li>
    <li>NOOP when there is no change</li>
  </ul></li>
  <li><em>Orchestration</em>: Splits the delta specification into independent subspecifications that can be planned and executed in isolation. Creates a <em>deployment plan</em> containing nested <em>subplans</em>, a combination of a subspecification and a list of <em>steps</em> needed to execute the subspecification.</li>
  <li><em>Planning</em>: Adds <em>steps</em> to each subplan that, when executed, perform the actions needed to execute the actual deployment.</li>
  <li><em>Execution</em>: Executes the complete deployment plan to perform the deployment.</li>
</ul><h2>Deployments and Plugins</h2><p>The following diagram depicts the way in which a plugin is involved in a deployment:</p><p><img src="images/Deployment-full.png"  alt="Deployment"/></p><p>The transitions that are covered by a puzzle-piece are the ones that interact with the plugins, whereas the deployit-logo indicates that the transition is handled by the Deployit core.</p><p>The following sections describe how plugins are involved in the above mentioned activities. To clarify the description, we will use the sample deployment package PetClinic 1.0, consisting of an EAR file, a datasource and static content, and deploy it to a WebSphere environment.</p><p>The plugin is involved in the Specification and Planning stages, these will be detailed below.</p><h3>Specification</h3><p>In the Specification stage, the deployment to be executed is specified. This includes selecting the deployment package and members to be deployed, as well as mapping each package member to the environment members that they should be deployed to.</p><h4>Specifying CIs</h4><p>The Deployit plugin defines which CIs the Deployit core can use to create deployments. When a plugin is loaded into the Deployit core, Deployit scans the plugin for CIs and adds these to its CI registry. Based on the CI information in the plugin, Deployit will categorize each CI as either a deployable CI (defining the <em>what</em> of the deployment) or a container CI (defining the <em>where</em> of the deployment).</p><h4>Specifying Relationships</h4><p>Where the deployable CI represents the passive resource or artifact, the deployed CI represents the <em>active</em> version of the deployable CI when it has been deployed in a container. By defining deployed CIs, the plugin indicates which combinations of deployable and container are supported.</p><h4>Configuration</h4><p>Each deployed CI represents a combination of a deployable CI and a container CI. It is important to note that one deployable CI can be deployed to multiple container CIs. For instance, an EAR file can be deployed to two application servers. In a deployment, this is modeled as multiple deployed CIs.</p><p>Sometimes it is desirable to configure a deployable CI differently depending on the container CI or environment it is deployed to. This can be done by configuring the properties of the deployed CI differently.</p><p>Configuring the deployed CIs is handled in the Deployit core. Users perform this task either via the GUI or via the CLI. A delpoyit plugin can influence this process by providing default values for its properties.</p><h4>Result</h4><p>The result of the Specification stage is a deployment specification, containing deployed CIs that describe which deployable CIs are mapped to which container CIs with the needed configuration.</p><h3>Planning</h3><p>In the Planning stage, the deployment specification and its subplans that were created in the Orchestration stage are processed.</p><p>During this stage, the Deployit core performs the following procedure:</p>
<ul>
  <li>Preprocessing</li>
  <li>Contributor processing</li>
  <li>Postprocessing</li>
</ul><p>During each part of this procedure, the Deployit plugin is invoked so it can contribute (add) required deployment steps to the subplan.</p><h4>Preprocessing</h4><p>Preprocessing allows the plugin to contribute steps to the very beginning of the plan. During preprocessing, all <em>preprocessors</em> defined in the plugin are invoked in turn. Each preprocessor has full access to the delta specification. As such, the preprocessor can contribute steps based on the entire deployment. Examples of such steps are sending an email before starting the deployment or performing pre-flight checks on CIs in that deployment.</p><h4>Deployed CI processing</h4><p>Dployed CIs contain both the data and the behavior to make a deployment happen. Each of the deployed CIs that is part of the deployment can contribute steps to ensure that they are deployed or configured correctly.</p><p>Steps in a deployment plan must be specified in the correct order for the deployment to succeed. Furthermore, the order of these steps must be coordinated among an unknown number of plugins. To achieve this, Deployit weaves all the separate resulting steps from all the plugins together by looking at their specified ordering.</p><p>For example, suppose we have a container CI representing a WAS application server called WasServer. This CI contains the data describing a WAS server (things like host, application directory, etc.) as well as the behavior to manage it. During a deployment to this WasServer, the WasServer CI contributes steps with order 10 to stop the WasServer. Also, it would contribute steps with order 90 to restart it. In the same deployment, a deployable CI called WasEar (representing the WAS EAR file) contributes steps to install itself with order 40. The resulting plan would weave the install of the EAR file (40) in between the stop (10) and start (90) steps.</p><p>This mechanism allows steps (behavior) to be packaged together with the CIs that contribute them. Also, CIs defined by separate plugins can work together to produce a well-ordered plan.</p><p>Deployit uses the following default orders:</p>
<ul>
  <li>PRE_FLIGHT (<strong>0</strong>)</li>
  <li>STOP_ARTIFACTS (<strong>10</strong>)</li>
  <li>STOP_CONTAINERS (<strong>20</strong>)</li>
  <li>UNDEPLOY_ARTIFACTS (<strong>30</strong>)</li>
  <li>DESTROY_RESOURCES (<strong>40</strong>)</li>
  <li>CREATE_RESOURCES (<strong>60</strong>)</li>
  <li>DEPLOY_ARTIFACTS (<strong>70</strong>)</li>
  <li>START_CONTAINERS (<strong>80</strong>)</li>
  <li>START_ARTIFACTS (<strong>90</strong>)</li>
  <li>POST_FLIGHT (<strong>100</strong>)</li>
</ul><h4>Postprocessing</h4><p>Postprocessing is similar to preprocessing, but allows a plugin to add one or more steps to the very end of a plan. A postprocessor could for instance add a step to send a mail once the deployment has been completed.</p><h4>Result</h4><p>The Planning stage results in a deployment plan that contains all steps necessary to perform the deployment. The deployment plan is ready to be executed.</p><p>This concludes the involvement of the plugin in the deployment planning process.</p><h2>Writing a plugin in Java</h2><p>In addition to extending Deployit plugins using the facilities described above, Deployit plugins can also be written in Java. The UDM concepts are represented in Java by interfaces:</p>
<ul>
  <li><em>Deployable</em> classes represent deployable CIs.</li>
  <li><em>Container</em> classes represent container CIs.</li>
  <li><em>Deployed</em> classes represent deployed CIs.</li>
</ul><p>In addition to these types, plugins also specify the behavior required to perform the deployment. That is, which actions (steps) are needed to ensure that a deployable ends up in the container as a deployed. In good OO-fashion, this behavior is part of the Deployed class.</p><p>Let's look at the mechanisms available to plugin writers in each of the two deployment phases, Specification and Planning.</p><h3>Specifying a Namespace</h3><p>All of the CIs in Deployit are part of a namespace to distinguish them from other, similarly named CIs. For instance, CIs that are part of the UDM plugin all use the <em>udm</em> namespace (such as <em>udm.Deployable</em>).</p><p>Plugins implemented in Java must specify their namespace in a source file called <em>package-info.java</em>. This file provides package-level annotations and is required to be in the same package as your CIs. </p><p>This is an example package-info file:</p>
<pre><code>@Prefix(&quot;yak&quot;)
package com.xebialabs.deployit.plugin.test.yak.ci;

import com.xebialabs.deployit.plugin.api.annotation.Prefix;
</code></pre><h3>Specification</h3><p>This section describes Java classes used in defining CIs that are used in the Specification stage.</p><h4>udm.ConfigurationItem and udm.BaseConfigurationItem</h4><p>The udm.BaseConfigurationItem is the base class for all the standard CIs in Deployit. It provides the <em>syntheticProperties</em> map and a default implementation for the name of a CI.</p><h4>udm.Deployable and udm.BaseDeployable</h4><p>The udm.BaseDeployable is the default base class for types that are deployable to <em>udm.Container</em> CIs. It does not add any additional behavior</p><h4>udm.Container and udm.BaseContainer</h4><p>The udm.BaseContainer is the default base class for types that can contain <em>udm.Deployable</em> CIs. It does not add any additional behavior</p><h4>udm.Deployed and udm.BaseDeployed</h4><p>The udm.BaseDeployed is the default base class for types that specify which <em>udm.Deployable</em> CI can be deployed onto which <em>udm.Container</em> CI. </p><h4>Additional UDM concepts</h4><p>Next to these base types, the UDM defines a number of implementations with higher level concepts that facilitate deployments.</p>
<ul>
  <li><strong>udm.Environment</strong>: The Environment is the target for a deployment in Deployit. It has members of type <em>udm.Container</em></li>
  <li><strong>udm.Application</strong>: The Application is a grouping of multiple <em>udm.DeploymentPackage</em> CIs that can each be the source of a deployment (for example: application = PetClinic; version = 1.0, 2.0, ...)</li>
  <li><strong>udm.DeploymentPackage</strong>: A deployment package has a set of <em>udm.Deployable</em> CIs, and it is the source for a deployment in Deployit.</li>
  <li><strong>udm.DeployedApplication</strong>: The DeployedApplication resembles the deployment of a _udm.DeploymentPackage to a <em>udm.Environment</em> with a number of specific <em>udm.Deployed</em> CIs</li>
  <li><strong>udm.Artifact</strong>: An implementation of a <em>udm.Deployable</em> which resembles a 'physical' artifact on disk (or memory)</li>
  <li><strong>udm.FileArtifact</strong>: A <em>udm.Artifact</em> which points to a single file</li>
  <li><strong>udm.FolderArtifact</strong>: A <em>udm.Artifact</em> which points to a directory structure</li>
</ul><h3>Mapping Deployables to Containers</h3><p>When creating a deployment, the deployables in the package are targeted to one or more containers. The deployable on the container is represented as a deployed. Deployeds are defined by the deployable CI type and container CI type they support. Registering a deployed CI in Deployit informs the system that the combination of the deployable and container is possible and how it is to be configured. Once such a CI exists, Deployit users can create them in the GUI by dragging the deployable to the container.</p><h3>Planning</h3><p>During planning a Deployment plugin can contribute steps to the deployment plan. Each of the mechanisms that can be used is described below</p><h4>@PrePlanProcessor and @PostPlanProcessor</h4><p>The @PrePlanProcessor and @PostPlanProcessor annotations can be specified on a method to define a pre- or postprocessor. The pre- or postprocessor takes an optional order attribute which defaults to '100'; lower order means it is earlier, higher order means it is later in the processor chain. The method should take a <em>DeltaSpecification</em> and return either a <em>Step</em> or <em>List of Step</em>, the name can be anything, so you can define multiple pre- and postprocessors in one class. See these examples:</p>
<pre><code>@PrePlanProcessor
public Step preProcess(DeltaSpecification specification) { ... }

@PrePlanProcessor
public List&lt;Step&gt; foo(DeltaSpecification specification) { ... }

@PostPlanProcessor
public Step postProcess(DeltaSpecification specification) { ... }

@PostPlanProcessor
public List&lt;Step&gt; bar(DeltaSpecification specification) { ... }
</code></pre><p>As a pre- or postprocessor is instantiated when it is needed, it should have a default constructor. Any fields on the class are not set, so the annotated method should not rely on them being set.</p><h4>@Create, @Modify, @Destroy, @Noop</h4><p>Deployeds can contribute steps to a deployment in which it is present. The methods that are invoked should also be specified in the <em>udm.Deployed</em> CI. It should take a DeploymentPlanningContext, to which one or more Steps can be added with specific ordering. The return type of the method should be <em>void</em>.</p><p>The method is annotated with the operation that is currently being performed on the Deployed CI. The following operations are available:</p>
<ul>
  <li><code>@Create</code> when deploying a member for the first time</li>
  <li><code>@Modify</code> when upgrading a member</li>
  <li><code>@Destroy</code> when undeploying a member</li>
  <li><code>@Noop</code> when there is no change</li>
</ul><p>In the following example, the method <code>createEar()</code> is called for both a <em>create</em> and <em>modify</em> operation of the DeployedWasEar.</p>
<pre><code>public class DeployedWasEar extends BaseDeployed&lt;Ear, WasServer&gt; {
    ...

    @Create @Modify
    public void createEar(DeploymentPlanningContext context) {
       // do something with my field and add my steps to the result
       // for a particular order
       context.addStep(40, new CreateEarStep(this));
    }
}
</code></pre><h4>@Contributor</h4><p>A @Contributor contributes steps for the set of <code>Deltas</code> in the current subplan being evaluated. The methods annotated with @Contributor can be present on any Java class which has a default constructor. The generated steps should be added to the collector argument <em>context</em>.</p>
<pre><code>@Contributor
public void contribute(Deltas deltas, DeploymentPlanningContext context) { ... }
</code></pre><h3>Control Tasks</h3><p>CIs programmed in Java can also define <em>control tasks</em>. Control tasks allow actions to be executed on CIs and can be invoked from the GUI or the CLI. Control tasks are implemented in Java as methods annotated with the @ControlTask annotation. The method returns a <em>List<Step></em> that the server will execute when it is invoked. Here is an example of a control task:</p>
<pre><code>@ControlTask(description = &quot;Start the Apache webserver&quot;)
public List&lt;Step&gt; start() {
    // Should include actual steps here
    return newArrayList();
}
</code></pre><p>A CI representing an Apache webserver could define the above method to start the webserver when invoked.</p><h3>Validation rules</h3><p>Next to defining CIs, new validation rules can also be defined in Java. These can then be used to annotate CIs or their properties so that Deployit can perform validations.</p><p>A simple property validation rule would look like:</p>
<pre><code>import com.xebialabs.deployit.plugin.api.validation.Rule;
import com.xebialabs.deployit.plugin.api.validation.ValidationContext;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Rule(clazz = StaticContent.Validator.class, type = &quot;static-content&quot;)
@Target(ElementType.FIELD)
public @interface StaticContent {
    String content();

    public static class Validator
           implements com.xebialabs.deployit.plugin.api.validation.Validator&lt;String&gt; {
        private String content;

        @Override
        public void validate(String value, ValidationContext context) {
            if (value != null &amp;&amp; !value.equals(content)) {
                context.error(&quot;Value should be %s but was %s&quot;, content, value);
            }
        }
    }
    }
</code></pre><p>A validation rule consists of an annotation <em>@StaticContent</em>, which is associated with an implementation of <em>com.xebialabs.deployit.plugin.api.validation.Validator&lt;T&gt;</em>. They are associated using the <em>@com.xebialabs.deployit.plugin.api.validation.Rule</em> annotation. Each method of the annotation needs to be present in the validator as a property with the same name.</p><p>When you've defined this validation rule, you can use it to annotate a CI like such:</p>
<pre><code>public class MyLinuxHost extends BaseContainer {
    @Property
    @StaticContent(content = &quot;/tmp&quot;)
    private String temporaryDirectory;
}
</code></pre><p>Or you can use it in synthetic XML in the following way:</p>
<pre><code>&lt;type name=&quot;ext.MyLinuxHost&quot; extends=&quot;udm.BaseContainer&quot;&gt;
    &lt;property name=&quot;temporaryDirectory&quot;&gt;
       &lt;rule type=&quot;static-content&quot; content=&quot;/tmp&quot;/&gt;
    &lt;/property&gt;
&lt;/type&gt;
</code></pre><h2>Packaging your plugin</h2><p>Plugins are distributed as standard Java archives (JAR files). Plugin JARs are put in the Deployit server <code>plugins</code> directory, which is added to the Deployit server classpath when it boots. Deployit will scan its classpath for plugin CIs and plugpoint classes and load these into its registry. These classes <strong>must</strong> be in the <em>com.xebialabs</em> or <em>ext.deployit</em> packages. The CIs are used and invoked during a deployment when appropriate.</p><p>Synthetic extension files packaged in the JAR file will be found and read. If there are multiple extension files present, they will be combined and the changes from all files will be combined.</p><h1>Appendices</h1><h2>Synthetic XSD</h2><p>This is the schema of the <em>synthetic.xml</em> file used to contribute types and type changes to Deployit.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
       xmlns=&quot;http://www.xebialabs.com/deployit/synthetic&quot;
       targetNamespace=&quot;http://www.xebialabs.com/deployit/synthetic&quot;
       elementFormDefault=&quot;qualified&quot;&gt;

    &lt;xs:element name=&quot;synthetic&quot;&gt;
        &lt;xs:complexType&gt;
            &lt;xs:choice maxOccurs=&quot;unbounded&quot;&gt;
                &lt;xs:element name=&quot;type&quot; type=&quot;SyntheticTypeDefinition&quot;/&gt;
                &lt;xs:element name=&quot;type-modification&quot; type=&quot;SyntheticTypeModification&quot;/&gt;
            &lt;/xs:choice&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:complexType name=&quot;SyntheticTypeDefinition&quot;&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;generate-deployable&quot; type=&quot;SyntheticDeployableGeneration&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
            &lt;xs:element name=&quot;property&quot; type=&quot;SyntheticPropertyDefinition&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
            &lt;xs:element name=&quot;method&quot; type=&quot;SyntheticMethodDefinition&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
            &lt;xs:element name=&quot;rule&quot; type=&quot;SyntheticValidationRule&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name=&quot;type&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;extends&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;virtual&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;deployable-type&quot; type=&quot;DeployitTypeName&quot;/&gt;
        &lt;xs:attribute name=&quot;container-type&quot; type=&quot;DeployitTypeName&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticDeployableGeneration&quot;&gt;
        &lt;xs:attribute name=&quot;type&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;extends&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticTypeModification&quot;&gt;
        &lt;xs:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
            &lt;xs:element name=&quot;property&quot; type=&quot;SyntheticPropertyDefinition&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt;
            &lt;xs:element name=&quot;method&quot; type=&quot;SyntheticMethodDefinition&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
            &lt;xs:element name=&quot;rule&quot; type=&quot;SyntheticValidationRule&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name=&quot;type&quot; type=&quot;DeployitTypeName&quot; use=&quot;required&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticPropertyDefinition&quot;&gt;
        &lt;xs:sequence&gt;
           &lt;xs:element name=&quot;rule&quot; type=&quot;SyntheticValidationRule&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name=&quot;name&quot; type=&quot;JavaPropertyName&quot; use=&quot;required&quot;/&gt;
        &lt;xs:attribute name=&quot;kind&quot; type=&quot;KindType&quot;/&gt;
        &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;category&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;label&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;required&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;password&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;size&quot; type=&quot;SizeType&quot;/&gt;
        &lt;xs:attribute name=&quot;default&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;enum-class&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:attribute name=&quot;referenced-type&quot; type=&quot;DeployitTypeName&quot;/&gt;
        &lt;xs:attribute name=&quot;as-containment&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;hidden&quot; type=&quot;xs:boolean&quot;/&gt;
        &lt;xs:attribute name=&quot;transient&quot; type=&quot;xs:boolean&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticMethodDefinition&quot;&gt;
       &lt;xs:attribute name=&quot;name&quot; type=&quot;JavaPropertyName&quot; use=&quot;required&quot; /&gt;
       &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot; /&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;SyntheticValidationRule&quot;&gt;
       &lt;xs:attribute name=&quot;type&quot; type=&quot;xs:string&quot; default=&quot;regex&quot; /&gt;
       &lt;xs:anyAttribute processContents=&quot;lax&quot;/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:simpleType name=&quot;JavaPropertyName&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:pattern value=&quot;[a-zA-Z0-9_]*&quot;/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:simpleType name=&quot;DeployitTypeName&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:pattern value=&quot;[a-zA-Z0-9-]*\.[a-zA-Z0-9-]*&quot;/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:simpleType name=&quot;KindType&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:enumeration value=&quot;enum&quot;/&gt;
            &lt;xs:enumeration value=&quot;boolean&quot;/&gt;
            &lt;xs:enumeration value=&quot;integer&quot;/&gt;
            &lt;xs:enumeration value=&quot;string&quot;/&gt;
            &lt;xs:enumeration value=&quot;ci&quot;/&gt;
            &lt;xs:enumeration value=&quot;set_of_ci&quot;/&gt;
            &lt;xs:enumeration value=&quot;set_of_string&quot;/&gt;
            &lt;xs:enumeration value=&quot;map_string_string&quot; /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:simpleType name=&quot;SizeType&quot;&gt;
        &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:enumeration value=&quot;default&quot;/&gt;
            &lt;xs:enumeration value=&quot;small&quot;/&gt;
            &lt;xs:enumeration value=&quot;medium&quot;/&gt;
            &lt;xs:enumeration value=&quot;large&quot;/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</code></pre><h2>Sample Java Plugin</h2><p>This example describes some classes from a test plugin we use at XebiaLabs, the Yak plugin.</p><p>We'll use the following sample deployment in this example</p>
<ul>
  <li>The YakApp 1.1 deployment package.</li>
  <li>The application contains two deployables: "yakfile1" and "yakfile2". Both are of type <em>YakFile</em>.</li>
  <li>An environment that contains one container: "yakserver", of type <em>YakServer</em>.</li>
  <li>An older version of the application, YakApp/1.0, is already deployed on the container.</li>
  <li>YakApp/1.0 contains an older version of yakfile1, but yakfile2 is new in this deployment.</li>
</ul><h3>Deployable: YakFile</h3><p>The <em>YakFile</em> is a deployable CI representing a file. It extends the built-in <em>BaseDeployableFileArtifact</em> class.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.ci;

import com.xebialabs.deployit.plugin.api.udm.BaseDeployableFileArtifact;

public class YakFile extends BaseDeployableFileArtifact {
}
</code></pre><p>In our sample deployment, both yakfile1 and yakfile2 are instances of this Java class.</p><h3>Container: YakServer</h3><p>The <em>YakServer</em> is the container that will be the target of our deployment.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.ci;

// imports omitted...

@Metadata(root = Metadata.ConfigurationItemRoot.INFRASTRUCTURE)
public class YakServer extends BaseContainer {

    @Contributor
    public void restartYakServers(Deltas deltas, DeploymentPlanningContext result) {
        for (YakServer yakServer : serversRequiringRestart(deltas.getDeltas())) {
            result.addStep(new StopYakServerStep(yakServer));
            result.addStep(new StartYakServerStep(yakServer));
        }
    }

    private static Set&lt;YakServer&gt; serversRequiringRestart(List&lt;Delta&gt; operations) {
        Set&lt;YakServer&gt; servers = new TreeSet&lt;YakServer&gt;();
        for (Delta operation : operations) {
            if (operation.getDeployed() instanceof RestartRequiringDeployedYakFile &amp;&amp; operation.getDeployed().getContainer() instanceof YakServer) {
                servers.add((YakServer) operation.getDeployed().getContainer());
            }
        }
        return servers;
    }
}
</code></pre><p>This class shows several interesting features:</p>
<ul>
  <li>The YakServer extends the built-in <em>BaseContainer</em> class.</li>
  <li>The @Metadata annotation specifies where in the Deployit repository the CI will be stored. In this case, the CI will be stored under the Infrastructure node. (see the Deployit Reference Manual for more information on the repository).</li>
  <li>The <code>restartYakServers()</code> method annotated with @Contributor is invoked when any deployment takes place (also deployments that may not necessarily contain an instance of the YakServer class). The method <code>serversRequiringRestart()</code> searches for any YakServer instances that are present in the deployment and that requires a restart. For each of these YakServer instances, a <em>StartYakServerStep</em> and <em>StopYakServerStep</em> is added to the plan.</li>
</ul><p>When the <em>restartYakServers</em> method is invoked, the <em>deltas</em> parameter contains operations for both yakfile CIs. If either of the yakfile CIs was an instance of <em>RestartRequiringDeployedYakFile</em>, a start step would be added to the deployment plan.</p><h3>Deployed: DeployedYakFile</h3><p>The <em>DeployedYakFile</em> represents a <em>YakFile</em> deployed to a <em>YakServer</em>, as reflected in the class definition. The class extends the built-in <em>BaseDeployed</em> class.</p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.ci;

// imports omitted...

public class DeployedYakFile extends BaseDeployed&lt;YakFile, YakServer&gt; {

    @Modify @Destroy
    public void stop(DeploymentPlanningResult result) {
        result.addStep(10, new StopDeployedYakFileStep(this));
    }

    @Create @Modify
    public void start(DeploymentPlanningResult result) {
        logger.info(&quot;Adding start artifact&quot;);
        result.addStep(90, new StartDeployedYakFileStep(this));
    }

    @Create
    public void deploy(DeploymentPlanningResult result) {
        logger.info(&quot;Adding step&quot;);
        result.addStep(70, new DeployYakFileToServerStep(this));
    }

    @Modify
    public void upgrade(DeploymentPlanningResult result) {
        logger.info(&quot;Adding upgrade step&quot;);
        result.addStep(70, new UpgradeYakFileOnServerStep(this));
    }

    @Destroy
    public void destroy(DeploymentPlanningResult result) {
        logger.info(&quot;Adding undeploy step&quot;);
        result.addStep(30, new DeleteYakFileFromServerStep(this));
    }

    private static final Logger logger = LoggerFactory.getLogger(DeployedYakFile.class);
}
</code></pre><p>This class shows how to use the @Contributor to contribute steps to a deployment that includes a configured instance of the DeployedYakFile. Each annotated method annotated is invoked when the specified operation is present in the deployment for the YakFile.</p><p>In our sample deployment, yakfile1 already exists on the target container CI so a <em>MODIFY</em> delta will be present in the delta specification for this CI, causing the <em>stop</em>, <em>start</em> and <em>upgrade</em> methods to be invoked on the CI instance. Because yakfile2 is new, a <em>CREATE</em> delta will be present, causing the <em>start</em>, and <em>deploy</em> method to be invoked on the CI instance.</p><h3>Step: StartYakServerStep</h3><p>Steps are the actions that will be executed when the deployment plan is started. </p>
<pre><code>package com.xebialabs.deployit.plugin.test.yak.step;

// imports omitted...

public class StartYakServerStep implements Step {

    private YakServer server;

    public StartYakServerStep(YakServer server) {
        this.server = server;
    }

    @Override
    public String getDescription() {
        return &quot;Starting &quot; + server;
    }

    @Override
    public Result execute(StepExecutionContext ctx) throws Exception {
        return Step.Result.Success;
    }

    public YakServer getServer() {
        return server;
    }
}
</code></pre></body></html>