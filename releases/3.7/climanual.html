<html><head><LINK REL=StyleSheet HREF="css/deployit.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="css/ci-reference-api.css" TYPE="text/css" MEDIA=screen>
<script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
<script type="text/javascript" src="js/jquery.tableofcontents.min.js"></script>
<script type="text/javascript" charset="utf-8">
$(document).ready(function(){
    $("body").attr('id', 'top-toc');
    var title = $("<div class='manual-title'/>")
    title.html("<div class='title'>Command Line Interface Manual</div><div class='version'>Version <span class='version-number'>3.7.0-beta-1</span></div>");
    $("body").css('width', '100%');
    $("body").prepend(title);
    $("body").prepend($("<ol id='toc'/>"));
    $("#toc").tableOfContents("body", { topLinks: true, } );
});

</script>
<title>Command Line Interface Manual</title>
</head><body><h1>Preface</h1><p>Sometimes the need arises to interact <em>Deployit</em> programmatically. Discovering your middleware topology, setting up environments, importing packages and performing deployments are just some examples of parts of your deployment life-cycle that you may want to control or execute programmatically.</p><p>Just to make it possible for users to use <em>Deployit</em>'s powerful capabilities in a programmatic way, <em>Deployit</em> ships with a rich <em>Command Line Interface</em> (CLI) that makes it possible to control and administer most of its features. The aim of this manual is to describe and teach how to use the CLI.</p><p>The CLI has been designed to allow it to be programmed by using the standard <a href="http://www.python.org/"><em>Python</em></a> programming language. This language has been specifically chosen as the default because most system administrators and developers are familiar with it. In the Appendix to this manual, all objects available for scripting are listed including an overview of the methods that can be invoked on them. Throughout this manual, examples will also show how to use the objects to perform various tasks when using the CLI.</p><p>The <em>Deployit</em> Reference Manual contains background information on <em>Deployit</em>, an overview of its features and a short explanation of basic deployment concepts. Together with this manual, it will present you with enough information to enable you to use the CLI to its full potential.</p><h1>CLI examples</h1><p>This manual contains example CLI snippets to illustrate how to use the Deployit CLI. These snippets are built using the <em>demo-plugin</em>, a sample plugin that shows some of Deployit's core features. The demo plugin can be downloaded from the Deployit community plugins website.</p><h1>Using the CLI</h1><p>The CLI connects to the <em>Deployit</em> server using the standardized HTTP / HTTPS protocol. This makes it possible to easily use the CLI remotely without hindrance from, e.g., firewalls.</p><p>To start the CLI successfully, the <em>Deployit</em> server to connect to must be running. See the <em>Deployit System Administrator Manual</em> for more information on how to startup the <em>Deployit</em> server.</p><h2>Environment variables</h2><p>After installing the <em>Deployit</em> CLI, set an environment variable named <code>DEPLOYIT_CLI_HOME</code> which points to the root directory where the CLI has been installed. In the remainder of this manual, the <code>DEPLOYIT_CLI_HOME</code> environment variable will be assumed to be set and to refer to the <em>Deployit</em> CLI installation directory.</p><p>A second environment variable, named <code>DEPLOYIT_CLI_OPTS</code> can be set in the startup <code>cli.cmd</code> or <code>cli.sh</code> script. This variable allows to override default JVM options and to set, for example, memory parameters. To set the initial Java heap size to 512 megabytes of memory, and the maximum Java heap size to 2 gigabytes of memory, the environment variable would be set like:</p>
<ul>
  <li><p><em>Unix</em> like platforms : <code>export DEPLOYIT_CLI_OPTIONS=&quot;-Xms512m -Xmx2g&quot;</code></p></li>
  <li><p><em>Windows</em> platforms : <code>set DEPLOYIT_CLI_OPTIONS=&quot;-Xms512m -Xmx2g&quot;</code></p></li>
</ul><p>Suggested options for the CLI are:</p>
<ul>
  <li>Minimum heap size 256 megabytes (<code>-Xms256m</code>)</li>
  <li>Minimum permgen space 256 megabytes (<code>-XX:MaxPermSize=256m</code>)</li>
</ul><h2>Starting the CLI</h2><p>To access the CLI, open a terminal window or command shell and change to the <code>DEPLOYIT_CLI_HOME/cli/bin</code> directory.</p><p>Once a terminal window or command shell has been opened and the directory changed to where the <em>Deployit</em> binaries are, the CLI may be started by entering the command <code>./cli.sh</code> on <em>Unix</em> like platforms, or <code>./cli.cmd</code> on <em>Windows</em> platforms.</p><p>When the CLI starts, it will prompt the user for a <code>username</code> and <code>password</code> combination and once these have been entered, it will attempt to connect to the <em>Deployit</em> server on <code>localhost</code> running on <em>Deployit</em>'s standard port of <code>4516</code>.</p><p>Once connected to the <em>Deployit</em> server, it will be possible to execute commands, within the limits of the granted permissions; see later section on security.</p><h2>Starting up with different settings</h2><p>By starting the CLI with the <code>-h</code> flag, the following message is shown which lists all possible options that may be used when starting up the CLI. Whenever <code>./cli.sh</code> is mentioned, it's understood to be read as <code>./cli.cmd</code> on <em>Windows</em> platforms:</p>
<pre><code>    ./cli.sh [options] [[--] arguments]

    options:

        -configuration VAL : Specify the location of the configuration file
        -context VAL       : The context Deployit is running at
        -f (-source) VAL   : Execute a specified python source file
        -host VAL          : Connect to a specified host, defaults to 127.0.0.1
        -port N            : Connect to a specified port, defaults to 4516
        -secure            : Use https to connect to the Deployit server
        -username VAL      : Connect as the specified user
        -password VAL      : Connect with the specified password
</code></pre><p>Following is a short explanation on how to use the available options:</p>
<ul>
  <li><p><code>-configuration /path/to/config/file</code></p><p>This option is used to pass the location of the <em>Deployit</em> configuration file. The default location for the configuration file is <code>conf/deployit.conf</code> in the <em>Deployit</em> installation directory.</p></li>
  <li><p><code>-context newcontext</code></p><p>If connecting to the <em>Deployit</em> server is hindered because of intermediate proxy servers, URL rewrite rules, etc., it's possible by use of this option to change the base part of <em>Deployit</em>'s URL. In the above example, the CLI will contact the Deployit server REST API at <code>http://host:port/newcontext/deployit</code>.</p><p>Note that the leading slash and REST API endpoint ('deployit') will automatically be added if they are omitted from the parameter.</p></li>
  <li><p><code>-f /path/to/Python/script</code></p><p>Starts the CLI in batch mode and instruct it to execute the script in the specified file. Once the script completes, the CLI will terminate.</p></li>
  <li><p><code>-source /path/to/Python/script</code></p><p>Alternative for the <code>-f</code> option.</p></li>
  <li><p><code>-host myhost.domain.com</code></p><p>Specifies the host where the <em>Deployit</em> server is running to connect to. The default host is <code>127.0.0.1</code>, i.e. <code>localhost</code>.</p></li>
  <li><p><code>-port 1234</code></p><p>Specifies the port at which to connect to the <em>Deployit</em> server. If the port is not specified, it will default to <em>Deployit</em>'s default port <code>4516</code>.</p></li>
  <li><p><code>-secure</code></p><p>This will make the CLI try to connect to the <em>Deployit</em> server on the secure port 4517. In order to be able to connect, the <em>Deployit</em> server must have been started using this secured port, which is the default. It is possible to startup using a different port using the <code>-port</code> option. Of course the <em>Deployit</em> server should also have started up using this port instead of the default one for a secure connection.</p></li>
  <li><p><code>-username myusername</code></p><p>Specifies the username to be used for login. If the username is not specified, the CLI will enter interactive mode and prompt the user.</p></li>
  <li><p><code>-password mypassword</code></p><p>Specifies the password to be used for login. If the password is not specified, the CLI will enter interactive mode and prompt the user.</p></li>
</ul><p>One example of using options might be:</p>
<pre><code>    ./cli.sh -username User -password UserPassword -context /deployit-proxy/deployit
</code></pre><p>This will log the user with username 'User' and password 'UserPassword' in on the CLI when connecting to the <em>Deployit</em> server running on the local machine ('localhost') and listening on port <code>4516</code>.</p><h3>Passing arguments to CLI commands or script</h3><p>As can be seen from the message shown in the previous section, next to options it's also possible to pass arguments from the command line to the CLI while starting up the CLI. It's not mandatory to specify any options in order to pass arguments. Following examples demonstrate two ways of passing arguments, one without options:</p>
<pre><code>    ./cli.sh these are four arguments
</code></pre><p>and one with options:</p>
<pre><code>    ./cli.sh -username User -port 8443 -secure again with four arguments
</code></pre><p>It is possible to begin an argument with the character &#39;<code>-</code>&#39;. In order for the CLI not to try to interpret it as an option instead of an argument, use the &#39;<code>--</code>&#39; seperator between the option list and the argument list:</p>
<pre><code>    ./cli.sh -username User -- -some-argument there are six arguments -one
</code></pre><p>This seperator only needs to be used in case one or more of the arguments begin with &#39;<code>-</code>&#39;.</p><p>The arguments may now be used in commands given on the CLI or be used in a script passed with the <code>-f</code> option, by using the <code>sys.argv[index]</code> method, whereby the index runs from 0 to the number of arguments, with the first argument having index 1, the second argument index 2, and so forth. Given the command line in the first example presented above, the commands</p>
<pre><code>    import sys
    print sys.argv[2] + &quot; &quot; + sys.argv[3] + &quot; &quot; + sys.argv[5]
</code></pre><p>would yield as a result:</p>
<pre><code>    there are arguments
</code></pre><h2>Logging in and Logging out</h2><p>Once the CLI has obtained the username and password of the user that wants to login, either by using the command line options or interactively, it will attempt to connect to the <em>Deployit</em> server at the specified (or default) address and port. If a successful connection can not be established, a stacktrace will be printed and the CLI will terminate.</p><p>If a successful connection with the <em>Deployit</em> server is established, a welcome message will be printed and the CLI is ready to accept commands.</p><h2>CLI extensions</h2><p>It is possible to install CLI extensions - 'extensions' for short - which are loaded during CLI startup. Extensions are nothing more but <em>Python</em> scripts, for example with <em>Python</em> class definitions, that will be available after CLI startup to be used in commands or scripts. This feature may be nicely combined with arguments given on the command line when starting up the CLI.</p><p>To install CLI extensions follow these steps:</p>
<ol>
  <li><strong>Create a directory called <code>ext</code></strong> This directory should be created in the same directory from which you will start the CLI - during startup the current directory will be searched for the existence of the <code>ext</code> directory.</li>
  <li><strong>Copy Python scripts into the <code>ext</code> directory</strong></li>
  <li><strong>(Re)Start the CLI</strong> During startup, the CLI will search for, load and execute all scripts with the <code>py</code> or <code>cli</code> suffix found in the extension directory.</li>
</ol><p>Please note that the order in which loading and execution of scripts that are present in the extension directory will take place, is not guaranteed!</p><h1>Objects available on the CLI</h1><p>This chapter describes the various objects available on the CLI for scripting. At present there are five objects available, to wit: <code>deployit</code>, <code>deployment</code>, <code>repository</code>, <code>factory</code> and <code>security</code>.</p><p>Next to the four available objects, it's also possible to define custom helper objects. A brief description of these four objects and how to define custom helper objects will be given in the next sections. The next chapters will present examples on how to use these objects for scripting purposes.</p><h2>The deployit object</h2><p>The <code>deployit</code> object provides access to the main functions of <em>Deployit</em> itself. It allows the user to import a package, work with tasks - stopping, starting, canceling or aborting tasks - and executing discovery.</p><h2>The deployment object</h2><p>The <code>deployment</code> object provides access to the deployment engine of <em>Deployit</em>. Using this object it is possible to create a task for an initial or upgrade deployment. It's also possible to generate a task for just a single deployment. The task thus created can be executed by using the <code>deployit</code> object and hence actually executing the deployment itself.</p><h2>The repository object</h2><p>The <code>repository</code> object allows the user to access <em>Deployit</em>'s repository. This includes searching the repository and performing Create, Read, Update and Delete (CRUD) operations on Configuration Items (CI) in the repository. It's also possible to export the complete task overview , or just the ones within a specified date range, to a local XML file.</p><h2>The factory object</h2><p>The <code>factory</code> object facilitates the creation of new Configuration Items (CI) and artifacts. These will be saved in <em>Deployit</em>'s repository. Artifacts are all sorts of files and packages.</p><h2>The security object</h2><p>The <code>security</code> object facilitates the login or logout of <em>Deployit</em> and the creation or deletion of users in <em>Deployit</em>'s own repository. Users of <em>Deployit</em> may also be administered using another credentials store like a LDAP directory, but creation and deletion of users on these specific stores is not within <em>Deployit</em>'s scope.</p><p>Users with administrative permissions my also grant, deny or revoke security permissions to other users, even those users that are not administered in <em>Deployit</em>'s repository but in some other credentials store. By default, users with administrative permissions own <strong>all</strong> permissions available in <em>Deployit</em>.</p><h2>Help with CLI objects when logged in</h2><p>As stated in the previous section, a welcome message is shown once the user has been successfully logged in. This message looks like:</p>
<pre><code>    Welcome to the Deployit Jython CLI!
    Type &#39;help&#39; to learn about the objects you can use to interact with Deployit.

    Deployit Objects available on the CLI

    deployit: The main gateway to interfacing with Deployit.
    deployment: Access to the deployment engine of Deployit.
    factory: Helper that can construct Configuration Items (CI) and artifacts.
    repository: Gateway to doing CRUD operations on all types of CIs.
    security: Access to the security settings of Deployit.

    To know more about a specific object, type &lt;objectname&gt;.help()
    To get to know more about a specific method of an object, type &lt;objectname&gt;.help(&quot;&lt;methodname&gt;&quot;)
</code></pre><p>To have this message shown again, just type <code>help</code> on the CLI command prompt, followed by <code>&lt;enter&gt;</code>.</p><p>Looking at the last paragraph of this message, one can see that it is easy to obtain information about a specific object by, for example, issuing the command:</p>
<pre><code>    deployit&gt; security.help()
</code></pre><p>This will list all methods on the specific object like <code>security</code> available for scripting. Extensive help about the exact usage of a specific method can be obtained by issuing a command like:</p>
<pre><code>    deployit&gt; security.help(&#39;getPermissions&#39;)
</code></pre><p>on the object in question. Notice that the name of the method is given enclosed in quote marks and without parentheses.</p><p>Also, the Appendix of this manual lists all objects available on the CLI for scripting as well as a description of the methods available on those objects with their required parameters.</p><h1>Setting up Security</h1><p>After a fresh installation of <em>Deployit</em> no permissions are granted to any user. The only users that have any permissions granted to them, are the <code>administrator</code> users and they will, by default, have <strong>all</strong> permissions granted to them. Currently, <em>Deployit</em> ships with one predefined administrator user called <code>admin</code>, with default password <code>admin</code>.</p><p>So the first task an <code>admin</code> user should do, is change the default password to something hard to guess and keep this password private. The next tasks should consist of adding users to <em>Deployit</em>'s repository - if no other credentials store is in use, or possibly in addition to another credentials store that will be used - and granting permissions to users that will work with <em>Deployit</em>, starting with the (global) permission to login.</p><h2>Adding users to the repository</h2><p>In a typical medium to large size company, there are several different groups of people that perform tasks related to deployments. For example, there are administrators that install, test and maintain hardware and there are deployers that deploy applications to development, test, acceptance as well as production environments. And obviously there are developers who build the applications waiting to be deployed to their respective target environments.</p><p>Creating and deleting users can be done using the following commands:</p>
<pre><code>    deployit&gt; security.createUser(&#39;John&#39;, &#39;Doe&#39;)
    deployit&gt; security.deleteUser(&#39;John&#39;)
</code></pre><p>Users created this way will however only end up in <em>Deployit</em>'s own repository. In order to create users in, for example, an LDAP credentials store, use your favorite LDAP administration tool.</p><p>The concept of groups is also supported by <em>Deployit</em> when using LDAP as the credentials store. All groups defined in LDAP can be assigned permissions in <em>Deployit</em> and users belonging to these groups will be assigned the group permissions when they use the system.</p><h2>Granting, revoking and denying permissions to users</h2><p>Permissions in the <em>Deployit</em> security system are either global or local. Global permissions that are granted to the user are in effect for <strong>all</strong> Configuration Items (CI) in the repository, meaning the permission is granted on <strong>all</strong> Configuration Items (CI), even the CI's that will be created after the permission has been granted. On the other hand, local permissions are set on specific CI's in the repository and need not be automatically in effect for newly created CI's.</p><p>Setting global and/or local permissions will result in a so-called <code>Access Control Entry</code> (ACE) being added to the user's <code>Access Control List</code> (ACL). Permissions set on CI's are <strong>transitive</strong>, meaning that a permission set on a CI will also be in effect on all of its children, their children and so forth, unless explicitly denied.</p><p>A permission can be either granted, denied or revoked:</p>
<ul>
  <li><code>granted</code>  a user will be explicitly allowed to execute a specific task</li>
  <li><code>denied</code>  a user will be explicitly denied to execute a specific task</li>
  <li><code>revoked</code>  a user's previously <code>granted</code> permission will be revoked, whereby the user is no longer allowed to execute this  specific task, but it will not be explicitly denied.</li>
</ul><h3>Permissions available in the security system</h3><p>Following is a list of all permissions available in <em>Deployit</em>'s security system. Some permissions are termed <code>global</code>, meaning that they are in effect on <strong>all</strong> CI's. Permissions not specifically termed <code>global</code> can be either allowed on all CI's, by not specifying any CI's on which the permission should be in effect, or an a set of CI's - and their children! - by specifying a list of the specific CI's the permission should be in effect upon.</p><p>See the <strong>System Administration Manual</strong> for a list of the available permissions.</p><h2>Managing Users</h2><p>Sometimes it proofs necessary to change a user's password, to delete a user or to login as a different user in order to perform a specific task with a different set of permissions. An example of this latter case might be the user <code>admin</code> that normally would work using another username with less permissions to perform regular deployment tasks, but needs to switch to <code>admin</code> in order to, for example, create a new user.</p><p>And sometimes it proofs useful - in case of troubleshooting for instance - to just be able to see what permissions exactly have been granted to what user on which CI's.</p><h3>Changing a user's password</h3><p>If for some reason a user's password gets compromised or the user has forgotten it, it will be possibly to set a new password for the user. Note that it will not be possibly to retrieve the user's password since <em>Deployit</em> does not store it as plain text. When requesting and viewing a user CI, passwords will always be shown as eight asterisks (*).</p><p>In order to change the password for user <code>developer</code>, issue following command:</p>
<pre><code>    deployit&gt; security.createUser(&#39;John&#39;, &#39;Doe&#39;)

    deployit&gt; devUser = security.readUser(&#39;John&#39;)
    deployit&gt; devUser.password = &#39;newpassword_1&#39;
    deployit&gt; security.modifyUser(devUser)
</code></pre><p>Please note the difference between the name of the user in the first command, <code>John</code>, and the object representing this user that was returned after executing the first command; this <code>user</code> object need also be used in the next two commands following the first one.</p><h3>Login as a different user</h3><p>It is possible to login as a different user once the CLI has started up. In order to log in as another user, you must first logout the user that is currently logged in. This will show the <code>deployit&gt;</code> prompt from which it is then possible to login again as a different user.</p><p>In following example an administrator is logged in as user <code>alice</code> and needs to login as <code>admin</code> to delete user <code>John</code>.</p>
<pre><code>    deployit&gt; security.logout()
    deployit&gt; security.login(&#39;admin&#39;, &#39;admin&#39;)

    # Delete the user John
    deployit&gt; security.deleteUser(&#39;John&#39;)

    #switch back to the account with less privileges
    deployit&gt; security.logout()
</code></pre><h3>Retrieving and listing user permissions</h3><p>In some cases, for instance trouble shooting, it's necessary to get an overview of the permissions granted to a specific user. A user logged in to <em>Deployit</em>'s CLI may also want to retrieve and list the granted or denied permissions. Deployit's CLI comes with some auxiliary methods on it's <em>security</em> object to retrieve and list granted or denied permissions.</p><p>To retrieve and show ones own permissions, assuming user 'deployer' is logged in, issue <code>security.getPermissions()</code> or, alternatively, <code>print security.getPermissions(&#39;deployer&#39;)</code></p><p>The latter form of the command will normally only be issued by an administrator user. This is because there exists a slight difference between both commands. The first command will just simple list all permissions of the user currently logged in on standard output. The second command will return a <code>PrincipalPermissions</code> object (see the appendix for a complete description of this object) on which the <code>getPermissions(&#39;deployer&#39;)</code> method is executed. Without the <code>print</code> statement, nothing would have shown up on standard output, because the method has a <code>PrincipalPermissions</code> object as its return value. In combination with the print statement, as shown in the above command, the object will print its string representation which, for this object, is a list of granted permissions and the CIs on which these have been granted.</p><p>The <code>PrincipalPermissions</code> object makes it possible to retrieve and inspect user permissions, to find out if a given user has any permissions at all or has a specific permission and on what CIs. This will, for example, allow an administrator to automate granting and/or revoking of permissions by use of a script, depending on the retrieved permissions and their state or CIs.</p><p>Take note that only an administrator user, i.e. <code>admin</code>, is allowed to retrieve permissions for another user and to grant, deny or revoke permissions. Normally it is only possible to retrieve and list ones own permissions. Trying to grant permissions using the second form of the command while not being logged in as user <code>admin</code>, will lead to an exception.</p><p>A somewhat more extensive example of using this object, to be executed as <code>admin</code>, is listed in following snippet:</p>
<pre><code>    deployit&gt; security.logout()
    deployit&gt; security.login(&#39;admin&#39;, &#39;admin&#39;)
    deployit&gt; security.createUser(&#39;alice&#39;, &#39;al1ce&#39;)
    deployit&gt; security.assignRole(&#39;deployer&#39;, [&#39;alice&#39;])
    deployit&gt; permissions = security.getPermissions(&#39;deployer&#39;)

    deployit&gt; if not permissions.hasPermission(&#39;login&#39;):
        security.grant(&#39;login&#39;, &#39;deployer&#39;)

    deployit&gt; if security.getPermissions(&#39;deployer&#39;).hasPermission(&#39;Applications/Dev&#39;, &#39;repo#edit&#39;):
        security.revoke(&#39;repo#edit&#39;, &#39;deployer&#39; [&#39;Applications/Dev&#39;])

    deployit&gt; security.removeRole(&#39;deployer&#39;)
    deployit&gt; security.deleteUser(&#39;alice&#39;)
</code></pre><h2>Example setting up initial security</h2><p>This example shows how to implement the security policy described in the <strong>Deployit System Administration Manual</strong>. To recap, here are the roles </p>
<ul>
  <li><strong>administrators</strong>: <em>repo#edit</em> permission on the Infrastructure and Environment trees.</li>
  <li><strong>frontend deployers</strong>: access to the <em>frontend</em> application directory, <em>deploy#initial</em> and <em>deploy#upgrade</em> on environments DEV and TEST, <em>read</em> rights on environment PROD.</li>
  <li><strong>backend deployers</strong>: access to the <em>backend</em> application directory, <em>deploy#initial</em> and <em>deploy#upgrade</em> on environments DEV and TEST, <em>read</em> rights on environment PROD.</li>
  <li><strong>senior deployers</strong>: <em>import#initial</em> permission for the applications, <em>deploy#initial</em> and <em>deploy#upgrade</em> permission on all environments.</li>
  <li><strong>developers</strong>: <em>import#upgrade</em> permission for the applications, <em>deploy#upgrade</em> on the DEV and TEST environments.</li>
</ul><p>The first task for a user with administrator privileges will be to create the users and roles in <em>Deployit</em> and allowing them to be able to login. Executing the following code will do this (the passwords in the examples are chosen for clarity. When creating users it's advisable to choose strong and difficult to guess passwords):</p>
<pre><code>    #
    # Sample security setup.
    #
    deployit&gt; security.createUser(&#39;alice&#39;, &#39;al1ce&#39;)
    deployit&gt; security.assignRole(&#39;administrators&#39;, [&#39;alice&#39;])
    deployit&gt; security.createUser(&#39;bob&#39;, &#39;b0b&#39;)
    deployit&gt; security.assignRole(&#39;senior-deployers&#39;, [&#39;bob&#39;])
    deployit&gt; security.createUser(&#39;carol&#39;, &#39;car0l&#39;)
    deployit&gt; security.assignRole(&#39;frontend-deployers&#39;, [&#39;carol&#39;])
    deployit&gt; security.createUser(&#39;dave&#39;, &#39;d@ve&#39;)
    deployit&gt; security.assignRole(&#39;backend-deployers&#39;, [&#39;dave&#39;])
    deployit&gt; security.createUser(&#39;mallory&#39;, &#39;mall0ry&#39;)
    deployit&gt; security.assignRole(&#39;developers&#39;, [&#39;mallory&#39;])

    deployit&gt; security.grant(&#39;login&#39;, &#39;administrators&#39;)
    deployit&gt; security.grant(&#39;login&#39;, &#39;senior-deployers&#39;)
    deployit&gt; security.grant(&#39;login&#39;, &#39;frontend-deployers&#39;)
    deployit&gt; security.grant(&#39;login&#39;, &#39;backend-deployers&#39;)
    deployit&gt; security.grant(&#39;login&#39;, &#39;developers&#39;)

    # Create some environments
    deployit&gt; infraGroup = repository.create(factory.configurationItem(&#39;Infrastructure/Dev&#39;,&#39;core.Directory&#39;,{}))
    deployit&gt; host = factory.configurationItem(infraGroup.id + &#39;/myHost&#39;, &#39;overthere.SshHost&#39;, {
                &#39;os&#39;:&#39;UNIX&#39;,
                &#39;address&#39;:&#39;localhost&#39;,
                &#39;username&#39;:&#39;deployit&#39;,
                &#39;password&#39;:&#39;deployit&#39;})
    deployit&gt; repository.create(host)
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Dev&#39;, &#39;core.Directory&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Test&#39;, &#39;core.Directory&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Acc&#39;, &#39;core.Directory&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Prod&#39;, &#39;core.Directory&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Dev/env&#39;, &#39;udm.Environment&#39;, { &#39;members&#39;: [&#39;Infrastructure/Dev/myHost&#39;] }))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Test/env&#39;, &#39;udm.Environment&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Acc/env&#39;, &#39;udm.Environment&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Environments/Prod/env&#39;, &#39;udm.Environment&#39;))
    # Import a application
    deployit&gt; repository.create(factory.configurationItem(&#39;Applications/team1&#39;,&#39;core.Directory&#39;,{}))
    deployit&gt; repository.create(factory.configurationItem(&#39;Applications/team1/PetClinic-ear&#39;,&#39;udm.Application&#39;,{}))
    deployit&gt; deployit.importPackage(&#39;PetClinic-ear/1.0&#39;)
</code></pre><p>Since the <code>login</code> permission is a global permission, there's no need to specify a list of CI's it will be in effect upon.</p><p>Next is to grant the individual roles their needed aggregated permissions in order for them to perform their tasks. The following snippet of code is a continuation of the above snippet; together with the snippets to come, it will constitute the complete script for this example.</p><p>The first role we will grant permissions to, is the <code>administrators</code> role. At minimum it needs <code>read</code> permission on the <code>Infrastructure</code> and <code>Environments</code> root nodes defined in <em>Deployit</em> and <code>repo#edit</code> permission in order to perform any creation, deletion and updating of CI's under these root nodes.</p>
<pre><code>    deployit&gt; security.grant(&#39;read&#39;, &#39;administrators&#39;,[&#39;Infrastructure&#39;, &#39;Environments&#39;])
    deployit&gt; security.grant(&#39;repo#edit&#39;, &#39;administrators&#39;, [&#39;Infrastructure&#39;, &#39;Environments&#39;, &#39;Applications&#39;])
</code></pre><p>Notice the use of a list of target CI's in the first command. The permissions will only be set on these two specified CI's - which happen to be the root nodes for <code>Infrastructure</code> and <code>Environments</code> in this case. If for instance a user exists who has limited administrator privileges, it would be possible to just grant the role of this user rights to specific environments by using the command:</p>
<pre><code>    deployit&gt; security.grant(&#39;repo#edit&#39;, &#39;administrators&#39;, [&#39;Environments/Prod&#39;])
</code></pre><p>Going back to the example, the senior-deployer needs the permissions to import and deploy applications to the DEV, TEST, ACC and PROD environments. Therefore, the permissions can be set "globally" and need not be set on specific CI's:</p>
<pre><code>    deployit&gt; security.grant(&quot;import#initial&quot;, &#39;senior-deployers&#39;, [&#39;Applications&#39;])
    deployit&gt; security.grant(&quot;import#upgrade&quot;, &#39;senior-deployers&#39;, [&#39;Applications&#39;])
    deployit&gt; security.grant(&quot;deploy#initial&quot;, &#39;senior-deployers&#39;, [&#39;Environments&#39;])
    deployit&gt; security.grant(&quot;deploy#upgrade&quot;, &#39;senior-deployers&#39;, [&#39;Environments&#39;])
</code></pre><p>Setting up permissions for the deployers will be a bit more complicated because of the restrictions imposed. Let's first create a separation of applications in frontend and backend. We do this by creating two directories:</p>
<pre><code>    deployit&gt; repository.create(factory.configurationItem(&#39;Applications/frontend&#39;, &#39;core.Directory&#39;))
    deployit&gt; repository.create(factory.configurationItem(&#39;Applications/backend&#39;, &#39;core.Directory&#39;))
</code></pre><p>Next, allow the frontend deployer to access the frontend applications and the same for the backend deployer. Both roles can deploy to the Dev, Test and Acc environments.</p>
<pre><code>    deployit&gt; security.grant(&quot;import#initial&quot;, &#39;frontend-deployers&#39;, [&#39;Applications&#39;])
    deployit&gt; security.grant(&quot;import#upgrade&quot;, &#39;frontend-deployers&#39;, [&#39;Applications/frontend&#39;])
    deployit&gt; security.grant(&quot;deploy#initial&quot;, &#39;frontend-deployers&#39;, [&#39;Environments/Dev&#39;, &#39;Environments/Test&#39;, &#39;Environments/Acc&#39;])
    deployit&gt; security.grant(&quot;deploy#upgrade&quot;, &#39;frontend-deployers&#39;, [&#39;Environments/Dev&#39;, &#39;Environments/Test&#39;, &#39;Environments/Acc&#39;])

    deployit&gt; security.grant(&quot;import#initial&quot;, &#39;backend-deployers&#39;, [&#39;Applications&#39;])
    deployit&gt; security.grant(&quot;import#upgrade&quot;, &#39;backend-deployers&#39;, [&#39;Applications/backend&#39;])
    deployit&gt; security.grant(&quot;deploy#initial&quot;, &#39;backend-deployers&#39;, [&#39;Environments/Dev&#39;, &#39;Environments/Test&#39;, &#39;Environments/Acc&#39;])
    deployit&gt; security.grant(&quot;deploy#upgrade&quot;, &#39;backend-deployers&#39;, [&#39;Environments/Dev&#39;, &#39;Environments/Test&#39;, &#39;Environments/Acc&#39;])
</code></pre><p>As can be seen from the commands in the snippet above, the deployers do not have permission to perform a deployment to the <code>Environments/Prod</code> environment. In order for them to see deployments in the production environment, <code>read</code> permission should be granted.</p>
<pre><code>    deployit&gt; security.grant(&#39;read&#39;, &#39;frontend-deployers&#39;, [&#39;Environments/Prod&#39;])
    deployit&gt; security.grant(&#39;read&#39;, &#39;backend-deployers&#39;, [&#39;Environments/Prod&#39;])
</code></pre><p>Finally permissions need to be granted to the <code>developer</code> role. This role is permitted to import new versions of applications into Deployit and to perform the deployment upgrade to the Dev and Test environments that goes hand in hand with this new version.</p>
<pre><code>    deployit&gt; security.grant(&quot;import#upgrade&quot;, &#39;developers&#39;, [&#39;Applications&#39;])
    deployit&gt; security.grant(&quot;deploy#upgrade&quot;, &#39;developers&#39;, [&#39;Environments/Dev&#39;, &#39;Environments/Test&#39;])
</code></pre><p>In this scenario the the <code>developer</code> role has the ability to import new versions of <strong>all</strong> applications known to <em>Deployit</em>. To restrict its import permission to new versions of some specific applications, like for example the <code>PetClinic</code> application, the following command can be issued:</p>
<pre><code>    deployit&gt; security.grant(&#39;import#upgrade&#39;, &#39;developers&#39;, [&#39;Applications/team1&#39;])
</code></pre><p>After the commands in the above snippets have been executed, the intial security setup of <em>Deployit</em> will match the intended security setup as described in the beginning of this section.</p><h1>Discovering middleware</h1><p>It is possible to let <em>Deployit</em> help with setting up your environment by attempting to discover the available middleware in your environment. In order to do this, <em>Deployit</em> will scan your environment for as far as possible and create Configuration Items in its repository based on the configurations it encounters during the scan. This process is knows as <em>discovery</em>.</p><p>The CIs discovered during <em>discovery</em> will help you in setting up your infrastructure in an easy way. However, they need not be complete: some CIs contain properties that can not be automatically discovered, like passwords. These specific kind of properties will still need to be entered manually.</p><p>Because <em>discovery</em> is part of the <em>Deployit</em> plugin suite, the exact discovery functionality available varies depending on the middleware platforms present in your environment.</p><p>The following steps comprise <em>discovery</em>:</p>
<ol>
  <li>Create a CI representing the starting point for <em>discovery</em> (often a <em>Host</em> CI).</li>
  <li>Start <em>discovery</em> passing this CI.</li>
  <li>Store the discoverd CIs in the repository.</li>
  <li>Complete the discovered CIs manually by providing missing needed properties.</li>
  <li>Add the discovered CIs to an environment.</li>
</ol><p>Note however that the last step of <em>discovery</em> is optional. The discovered CIs will be stored under the <code>Infrastructure</code> root node in the repository and may be added to an environment at some later time.</p><h3>Create a Configuration Item starting point</h3><p>The first step taken in <em>discovery</em> is to create a starting point to kick off the process from. This starting point consists of a Configuration Item specifying at least the host that <em>discovery</em> should start at. Depending on the middleware you are trying to discover, additional parameters may be needed.</p><p>Following is an example of how to perform <em>discovery</em> based on the demo-plugin, an example plugin that is part of XebiaLabs community-plugins repository. First a CI is created for the host the demo CIs are going to be discovered on. Then we create a CI for the demo server we want to discover. This CI will be the starting point for <em>discovery</em>.</p>
<pre><code>    # Create the host CI
    deployit&gt; host = factory.configurationItem(&#39;Infrastructure/demoHost&#39;, &#39;overthere.LocalHost&#39;)
    deployit&gt; host.os = &#39;UNIX&#39;
    deployit&gt; repository.create(host)

    deployit&gt; server = factory.configurationItem(&#39;Infrastructure/demoHost/demoServer&#39;, &#39;demo.Server&#39;)
    deployit&gt; server.host = host.id
</code></pre><h3>Start discovery passing a Configuration Item</h3><p>After the CI starting point has been created, it can be used to perform <em>discovery</em>. The <em>Deployit</em> CLI <em>discovery</em> functionality is synchronous, which means that the CLI will wait until the <em>discovery</em> process finishes.</p><p>The process of <em>discovery</em> works exactly like a regular task in that it executes a number of steps behind the scenes. Whenever one of these steps fails, the entire <em>discovery</em> fails and aborts. It is not possible to continue an interrupted <em>discovery</em> process.</p><p>The command to start discovery is:</p>
<pre><code>    deployit&gt; discoveredCIs = deployit.discover(server)
</code></pre><p>Note there are no single- or double quotes around <code>server</code>, because it's an object and not a string. The result of this command will be an object containing a list of discovered CIs.</p><h3>Store the CIs in the repository</h3><p>Deployit returns a list of discovered middleware CIs. Note that these are not yet persisted. To store them in the repository, use the following code:</p>
<pre><code>    deployit&gt; repository.create(discoveredCIs)
</code></pre><h3>Complete discovered middleware CIs</h3><p>The easiest way to find out which of the discovered CIs require additional information is by printing them. Any CIs that contain passwords (displayed as '********') will need to be completed. To print the stored CIs, the following code can be used:</p>
<pre><code>    deployit&gt; for ci in discoveredCIs.objects: deployit.print(repository.read(ci.id));
</code></pre><p>Note: the created CIs can also be edited in the GUI using the Repository Browser if they have been stored in the repository.</p><h3>Adding CIs to Environments</h3><p>Middleware that is used as a deployment target must be grouped together in an environment. Environments are CIs and like all CIs, they can be created from the CLI. The following command can be used for this:</p>
<pre><code>    deployit&gt; env = factory.configurationItem(&#39;Environments/DiscoveredEnv&#39;, &#39;udm.Environment&#39;)
</code></pre><p>Add the discovered CIs to the environment:</p>
<pre><code>    deployit&gt; env.values[&#39;members&#39;] = [ci.id for ci in discoveredCIs.objects]
</code></pre><p>Note that not all of the discovered CIs should necessarily be stored in an environment. For example, in the case of WAS, some nested CIs may be discovered of which only the top-level one must be stored.</p><p>Store the new environment:</p>
<pre><code>    deployit&gt; repository.create(env)
</code></pre><p>The newly created environment can now be used as a deployment target.</p><p>Note: the user needs specific permission to store CIs in the database. See the <em>Deployit System Administration Manual</em>.</p><h2>Performing deployments</h2><p>The Deployit CLI supports performing a deployment as well. Here is an example of how to perform a simple deployment (one where the default mappings suffice):</p>
<pre><code>    # Import package
    deployit&gt; package = deployit.importPackage(&#39;demo-application/1.0&#39;)

    # Load environment
    deployit&gt; environment = repository.read(&#39;Environments/DiscoveredEnv&#39;)

    # Start deployment
    deployit&gt; deploymentRef = deployment.prepareInitial(package.id, environment.id)
    deployit&gt; deploymentRef = deployment.generateAllDeployeds(deploymentRef)
    deployit&gt; taskID = deployment.deploy(deploymentRef).taskId
    deployit&gt; deployit.startTaskAndWait(taskID)
</code></pre><p>Undeployment follows the same general flow:</p>
<pre><code>    deployit&gt; taskID = deployment.undeploy(&#39;Environments/DiscoveredEnv/demo-application&#39;).taskId
    deployit&gt; deployit.startTaskAndWait(taskID)
</code></pre><h1>Working with Tasks</h1><p>Deployit can perform many deployments at the same time. Each of these deployments is called a <em>task</em>. Tasks are stored in the Deployit <em>task registry</em> which is periodically backed up to a file. If the Deployit server should crash, the tasks in the registry survive the crash and can be continued. Users can ask Deployit to start a task, stop a task or cancel a task.</p><p>Once a task is completed or canceled, it is moved to the <em>task archive</em>. This is where Deployit stores it's task history. You can query it for tasks and examine the tasks steps and logs or export the task archive to an XML file.</p><h2>Starting, stopping and canceling</h2><p>Whenever you start a deployment or undeployment in Deployit, the Deployit CLI returns a <em>Steps</em> object. This object describes the steps Deployit will take to execute your request, but it doesn't yet start execution. Instead, Deployit creates a task for the request and returns its id as the <em>taskId</em> field in the <em>Steps</em> object. You can use the task id to start, stop or cancel the task.</p><p>There are two ways to start a task in the Deployit CLI. We've already seen the first one -- <em>startTaskAndWait</em> starts the tasks and waits for it to complete. The <em>startTask</em> method starts the task in Deployit and returns immediately. Both methods are also used to re-start a failed task. </p><p>If a task is running and you want to attempt to stop it, use the <em>stopTask</em> method. This attempts to interrupt the currently running task.</p><p>The <em>cancelTask</em> method is used to cancel a task. That is, abandon execution of the task and move it to the archive.</p><h2>Listing tasks</h2><p>Before you can work with any of the tasks, you'll need to list them:</p>
<pre><code>    deployit&gt; print deployit.listUnfinishedTasks()
</code></pre><p>This retrieves and shows a list of unfinished tasks <em>that are assigned to the current user</em>. The method returns an array of <em>TaskInfo</em> objects which you can actually print:</p>
<pre><code>    deployit&gt; for t in deployit.listUnfinishedTasks(): print &quot;Task id &quot; + t.id + &quot; is assigned to user &quot; + t.username
</code></pre><p>If you have <em>admin</em> permission, you can also list <em>all</em> tasks in Deployit:</p>
<pre><code>    deployit&gt; print deployit.listAllUnfinishedTasks()
</code></pre><h2>Assigning tasks</h2><p>Tasks in Deployit are assigned to the user that started them. This means that they will appear in the Deployit GUI whenever this user logs out and back in again. </p><p>Deployit also supports re-assigning tasks. If you have <em>task#assign</em> permission, you are allowed to assign a task currently assigned to you to another principal. If you have the <em>admin</em> permission, you can assign any task in the system to another principal.</p><p>This is how you assign a task in the CLI:</p>
<pre><code>    # Import package
    deployit&gt; package = repository.read(&#39;Applications/demo-application/1.0&#39;)

    # Load environment
    deployit&gt; environment = repository.read(&#39;Environments/DiscoveredEnv&#39;)

    # Start deployment
    deployit&gt; deploymentRef = deployment.prepareInitial(package.id, environment.id)
    deployit&gt; deploymentRef = deployment.generateAllDeployeds(deploymentRef)
    deployit&gt; taskID = deployment.deploy(deploymentRef).taskId

    deployit&gt; deployit.assignTask(taskID, &#39;admin&#39;)

    # perform some operations on the task

    deployit&gt; deployit.cancelTask(taskID)
</code></pre><p><strong>Note</strong>: Deployit does not validate the principal you enter as the recipient of the task.</p><h2>Retrieving archived tasks from the repository</h2><p>The <em>repository</em> CLI object has facilities to retrieve an overview of all archived tasks, or a number of tasks within a specified date range.</p><p>The command to export all tasks is:</p>
<pre><code>    deployit&gt; archivedTasks = repository.getArchivedTasks()
</code></pre><p>This command will return an object on which you can interact with tasks and their interned steps. The returned object contains all tasks, and tasks in turn contain all of their steps. For instance, to get the number of tasks retrieved, execute:</p>
<pre><code>    deployit&gt; repository.getArchivedTasks().size()
</code></pre><p>or, when you've assigned the object to a variable named <code>archivedTasks</code>:</p>
<pre><code>    deployit&gt; archivedTasks.size()
</code></pre><p>To obtain the first retrieved Task from the object, yield:</p>
<pre><code>    deployit&gt; firstTask = archivedTasks.getTasks().get(0)
</code></pre><p>The task count starts at 0 to size() exclusive. This call will give you a <code>TaskInfo</code> object on which you may call all normally available methods. To obtain the first step from the acquired task, execute:</p>
<pre><code>    deployit&gt; firstStep = firstTask.getSteps().get(0)
</code></pre><p>Again, the count of steps starts at 0 to getSteps().size() exclusive. This will give you a <code>StepInfo</code> object on which all regular methods may be called.</p><p>Once you've obtained a <code>TaskInfo</code> or <code>StepInfo</code> object, you can query it for all relevant information, like, for instance in the case of a step, it's state:</p>
<pre><code>    deployit&gt; firstStep.getState()
</code></pre><p>or it's step number:</p>
<pre><code>    deployit&gt; firstStep.getNr()
</code></pre><p>Next to all tasks, one may also just export all tasks within a given date range executing the following command:</p>
<pre><code>    deployit&gt; repository.getArchivedTasks(&#39;01/01/2010&#39;, &#39;01/01/2011&#39;)
</code></pre><p>Both date parameters in the method signature should be specified in the following format <strong>mm/dd/yyyy</strong>, with <strong>m</strong> a month digit, <strong>d</strong> a day digit and <strong>y</strong> a year digit. The above method call will return an object that simply wraps the requested tasks, analogous to the getArchivedTasks() method call.</p><h3>Exporting archived tasks from the repository to a local XML file</h3><p>It's also possible to store the contents of the task repository to a local XML file. In order to store the complete task repository to a local XML file, use the following command:</p>
<pre><code>    deployit&gt; repository.exportArchivedTasks(&#39;/tmp/task-export.xml&#39;)
</code></pre><p>The variable <em>your-file-path</em> contains the complete path to the file, e.g.: <code>/tmp/my-xml.xml</code> on Unix/Linux systems or <code>d:/temp/my-xml.xml</code> on Windows systems. The last path may alternatively be typed as <code>d:\\temp\\my-xml.com</code> - notice the escaped backslash in this latter variant.</p><p>Of course it is also possible to export a number of tasks in a certain date range from the task repository to a local XML file using the following command:</p>
<pre><code>    deployit&gt; repository.exportArchivedTasks(&#39;/tmp/task-export.xml&#39;, &#39;01/01/2010&#39;, &#39;01/01/2011&#39;)
</code></pre><h1>Performing Common Tasks</h1><p>This section describes common tasks that may be performed using the CLI. Its main purpose is to present examples of how to combine commands to perform the desired tasks.</p><h2>Working with Configuration Items</h2><p>This section shows some examples of how to work with CIs. The two main objects involved are the <code>factory</code> object and the <code>repository</code> object. The <code>factory</code> object is used to actually create the CI itself, while with the <code>repository</code> object it is possible to store the CI in the repository.</p><h3>Finding out types of available CIs and their properties</h3><p>The available CIs and their respective type need to be known before being able to create one. Using the command</p>
<pre><code>    deployit&gt; factory.types()
</code></pre><p>an overview will be shown on standard output of all the available types that are shipped with <em>Deployit</em>. If at some point more plugins are added to <em>Deployit</em>, types defined therein will be added to <em>Deployit</em>'s type registry and will then also be available in addition to the types initially shipped with <em>Deployit</em>. The new types should also show up in the output of this command.</p><p>In order to obtain some more details of a specific type, for instance its required properties, execute the <code>describe</code> method on the <code>deployit</code> object with the fully qualified type name as its parameter:</p>
<pre><code>    deployit&gt; deployit.describe(&#39;udm.Dictionary&#39;)
</code></pre><p>The output of this command will show something like:</p>
<pre><code>    ConfigurationItem &quot;udm.Dictionary&quot; (udm.Dictionary):
    Description: A Dictionary contains key-value pairs that can be replaced

    Properties
        * environment(): The environment this dictionary belongs to
        * dict(MAP_STRING_STRING): The dictionary values

    Properties marked with a &#39;*&#39; are required.
</code></pre><h3>Creating common UDM CIs</h3><p>The following snippet shows examples of creating common UDM CIs.</p>
<pre><code>    # Create a host
    deployit&gt; sampleHost = factory.configurationItem(&#39;Infrastructure/sampleHost&#39;, &#39;overthere.SshHost&#39;,
       { &#39;os&#39;: &#39;UNIX&#39;, &#39;address&#39;: &#39;localhost&#39;, &#39;username&#39;: &#39;scott&#39; })
    deployit&gt; repository.create(sampleHost)
    deployit&gt; deployit.print(sampleHost)

    # Create a dictionary
    deployit&gt; sampleDict = factory.configurationItem(&#39;Environments/myDict&#39;, &#39;udm.Dictionary&#39;)
    deployit&gt; sampleDict.entries = { &#39;a&#39;: &#39;1&#39;, &#39;b&#39;: &#39;2&#39; }
    deployit&gt; repository.create(sampleDict)
    deployit&gt; deployit.print(sampleDict)

    # Create an environment
    deployit&gt; sampleEnv = factory.configurationItem(&#39;Environments/sampleEnv&#39;, &#39;udm.Environment&#39;)
    deployit&gt; sampleEnv.dictionaries = [ sampleDict.id ]
    deployit&gt; sampleEnv.members = [ sampleHost.id ]
    deployit&gt; repository.create(sampleEnv)
    deployit&gt; deployit.print(sampleEnv)
</code></pre><h3>Moving and Renaming CIs</h3><p>The repository allows you to move or rename CIs as well. Note that a CI can only be moved within the root node it was created in. That is, a CI under the <em>Application</em> root node can only be moved to another place in this tree.</p><p>The following snippet shows examples of moving and renaming CIs:</p>
<pre><code>    # Create a directory to store environments
    deployit&gt; directory = factory.configurationItem(&#39;Environments/ciGroup&#39;, &#39;core.Directory&#39;)
    deployit&gt; repository.create(directory)

    # Move the sample environment in the new directory
    deployit&gt; repository.move(sampleEnv, directory.id + &#39;/sampleEnv&#39;)
    deployit&gt; sampleEnv = repository.read(&#39;Environments/ciGroup/sampleEnv&#39;)

    # Rename the directory
    deployit&gt; repository.rename(directory, &#39;renamedCiGroup&#39;)
    deployit&gt; sampleEnv = repository.read(&#39;Environments/renamedCiGroup/sampleEnv&#39;)

    # References to renamed or moved CIs are kept up-to-date
    deployit&gt; repository.rename(sampleHost, &#39;renamedSampleHost&#39;)
    deployit&gt; sampleEnv = repository.read(&#39;Environments/renamedCiGroup/sampleEnv&#39;)
    deployit&gt; sampleHost = repository.read(sampleEnv.members[0])
</code></pre><p><strong>Note</strong>: moving or renaming CIs when deployments are in progress or when the CIs concerned are used by Deployit clients (GUI or CLI) is discouraged.</p><h2>Executing a Control Task</h2><p>Control tasks can be executed from the CLI as well. Take, for example, the <em>start</em> control task on a Glassfish server in the glassfish-plugin (available as a community plugin, see the introduction of this manual). It can be executed as follows:</p>
<pre><code>    deployit&gt; server = repository.read(&#39;Infrastructure/demoHost/demoServer&#39;)
    deployit&gt; deployit.executeControlTask(&#39;start&#39;, server)
</code></pre></body></html>