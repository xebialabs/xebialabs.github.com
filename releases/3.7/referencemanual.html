<html><head><LINK REL=StyleSheet HREF="deployit.css" TYPE="text/css" >
<LINK REL=StyleSheet HREF="ci-reference-api.css" TYPE="text/css">
<script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
<script type="text/javascript" src="js/jquery.tableofcontents.min.js"></script>
<script type="text/javascript" charset="utf-8">
$(document).ready(function(){
    $("body").attr('id', 'top-toc');
    var title = $("<div class='manual-title'/>")
    title.html("<div class='title'>Reference Manual</div><div class='version'>Deployit <span class='version-number'>3.7.2-SNAPSHOT</span></div>");
    $("body").prepend(title);
    $("body").prepend($("<ol id='toc'/>"));
    $("#toc").tableOfContents("body", { topLinks: false, } );
});

</script>
<title>Reference Manual</title>
</head><body><h1>Preface</h1><p>This manual contains reference information for users of Deployit.</p><h1>Deployment Overview</h1><p>Deployit is the first out-of-the-box deployment automation solution that allows non-experts to perform application deployments. A deployment consists of all the actions needed to install, configure and start an application on a target environment. </p><p>At a high level, deployments in Deployit are modeled using the <em>Unified Deployment Model (UDM)</em>. The following diagram depicts the main concepts in the UDM as they appear in the Deployit GUI:</p><p><img src="images/udm-highlevel-deployit.png"  alt="Unified Deployment Model"/></p><p>Deployments are defined by:</p>
<ul>
  <li>A <strong>Package</strong> containing <em>what</em> is to be deployed (shown on the left side of the picture).</li>
  <li>An <strong>Environment</strong> defining <em>where</em> the package is to be deployed (shown on the right side of the picture).</li>
  <li>Configuration of the <strong>Deployment</strong> specifying (possibly environment-specific) <em>customizations</em> to the package to be deployed (the middle square).</li>
</ul><p>Of course, packages and environments are made up of smaller parts:</p>
<ul>
  <li>Packages consist of <strong>deployables</strong> or <em>things that can be deployed</em>.</li>
  <li>Environments consist of <strong>containers</strong> or <em>things that can be deployed <em>to</em></em>.</li>
</ul><p>Deployables come in two flavors: <em>artifacts</em> are physical files (examples are an EAR file, a WAR file or a folder of static HTML) and <em>resource specifications</em> are middleware resources that the application needs to run (examples are a queue, a topic or a datasource). These types of deployables are put together in a package.</p><p>Containers are actual middleware products that deployables are deployed to. Examples of containers are an application server such as Tomcat or WebSphere, a database server, or a WebSphere node or cell.</p><p>Let's say we have a package that consists of an EAR file (an artifact), a datasource (a resource specification) and some configuration files (artifacts) and we want to deploy this package to an environment containing an application server and a host (both containers). The exact deployment could look something like this:</p><p><img src="images/udm-lowlevel-deployit.png"  alt="Unified Deployment Model Detail"/></p><p>In the above picture, you can see that the EAR file and the datasource are deployed to the application server and the configuration files are deployed to the host. </p><p>As you can see above, the deployment also consists of smaller parts. The combination of a particular deployable and container is called a <em>deployed</em>. Deployeds represent <em>the deployable on the container</em> and contain customizations for this specific deployable - container combination. For example, the <em>PetClinic-ds</em> deployed in the picture represents the datasource from the deployment package as it will be deployed to the <em>was.Server</em> container. The deployed allows a number of properties to be specified:</p><p><img src="images/udm-lowlevel-deployed-deployit.png"  alt="Unified Deployment Model - Deployed"/></p><p>For example, the deployed has a specific username and password that may be different when deploying the same datasource to another server.</p><p>Once a deployment is specified and configured using the concepts above (and the <em>what</em>, <em>where</em> and <em>customizations</em> are known), Deployit takes care of the <em>how</em> by preparing a list of steps that need to be executed to perform the actual deployment. Each step specifies one action to be taken, such as copying of a file, modifying a configuration file or restarting a server.</p><p>When the deployment is started, Deployit creates a <em>task</em> to perform the deployment. The task is an independent process running on the Deployit server. The steps are executed sequentially and the deployment is finished successfully when all steps have been executed. If an error occurs during deployment, the deployment stops and an operator is required to intervene.</p><p>The result of the deployment is stored in Deployit as a <em>deployed application</em> and is shown in the Deployed Application Browser on the right hand side of the GUI. The deployed applications are organised by environment so it is clear where the application is deployed to. It is also possible to see which parts of the deployed package have been deployed to which environment member.</p><p>The final result of our sample deployment looks like this:</p><p><img src="images/udm-lowlevel-deployedapplication-deployit.png"  alt="Unified Deployment Model - Deployed Application"/></p><h1>Interacting with Deployit</h1><p>There are two ways of interacting with Deployit and each is intended for a specific audience.</p><p>Performing tasks interactively is possible using the <strong>Graphical User Interface (GUI)</strong>. The GUI is a Flash application running inside a browser. After logging in, the user can configure and perform deployments; view the release pipeline of the different applications; view and edit the repository; view reports; and view or edit security settings. (Provided that the user has proepr access to these components of course) See the <strong>Deployit Graphical User Interface (GUI)</strong> manual for more information.</p><p>The <strong>Command Line Interface (CLI)</strong> is used to automate Deployit tasks. The CLI is a Jython application that the user can access remotely. In addition to configuring and performing deployments, the user can also setup middleware in the CLI. In general, the CLI is used to perform administrative tasks or automate deployment tasks. See the <strong>Deployit Command Line Interface (CLI)</strong> manual for more information.</p><p>Please note that Deployit's security system is applied to all user actions, regardless of whether they are performed in the GUI or from the CLI.</p><h1>Deployit Glossary</h1><p>These are the main concepts in Deployit, in alphabetical order.</p><h2>Artifacts</h2><p>Artifacts are files containing application resources such as code or images. The following are examples of artifacts:</p>
<ul>
  <li>a WAR file.</li>
  <li>an EAR file.</li>
  <li>a folder containing static content such as HTML pages or images.</li>
</ul><h2>Command Line Interface (CLI)</h2><p>The Deployit CLI provides a way to programmatically interact with Deployit. The CLI can be programmed using the <strong>Python</strong> programming language. For more detailed information, see the <strong>Deployit Command Line Interface Manual</strong>.</p><h2>Composite Packages</h2><p>Composite packages are deployment packages that have other deployment packages as members. Composite packages can not be imported, but are created inside of Deployit using other packages that are also in the Deployit repository. Deploying a composite package works the same as deploying a regular package. Note that Deployit has a composite package <em>orchestrator</em> that ensures that the deployment is carried out according to the ordering of the composite package members.</p><p>A typical use case for composite packages is to compose a release of an application that consists of components that are delivered by separate teams.</p><h2>Control Tasks</h2><p>Control tasks are actions that can be performed on middleware or middleware resources. </p><p>Control tasks are defined on a particular type and can be executed on a specific instance of that type. When a control task is invoked, Deployit starts a task that executes the steps associated with the control task. Deployit users can use them to interact directly with the underlying middleware. An example of a control task is starting or stopping of an Apache webserver.</p><p>Control tasks can be defined in Java or XML (see the <strong>Customization Manual</strong>) or using scripts (see the <strong>Generic Model Plugin Manual</strong>).</p><h2>Configuration Items (CIs)</h2><p>A <em>configuration item</em> (CI) is a generic term that describes all objects that Deployit keeps track of. Applications, middleware, environments and deployments in Deployit are all represented in Deployit as CIs. A CI has a certain <em>type</em> that determines what information it contains and what it can be used for. CIs have properties to describe it and may have relations to other CIs.</p><p>Deployit CIs all share one property:</p>
<ul>
  <li><strong>id</strong>. The unique identifier for this CI. The id determines the place of the CI in the repository.</li>
</ul><p>Some properties of a CI are mandatory. To determine which properties are available and which are mandatory or optional for a CI, see the <strong>CI Reference</strong> section in this document, the plugin manual for the plugin that provides the CI, or use the help facility in the Deployit CLI.</p><p>For example, a CI of type <code>udm.DeploymentPackage</code> represents a <em>deployment package</em>. It has properties containing its version number. It contains child CIs for the <em>artifacts</em> and <em>resource specifications</em> it contains and has a link to a parent CI of type <code>udm.Application</code> which describes which application the package is a part of.</p><h2>Containers</h2><p><em>Containers</em> are configuration items (CIs) that <em>deployable</em> CIs can be deployed to. Containers are grouped together in an <em>environment</em>. Examples of containers are a host, WebSphere server or WebLogic cluster.</p><h2>Deployables</h2><p><em>Deployables</em> are configuration items (CIs) that can be deployed to a container. Deployables are part of a <em>deployment package</em>. Deployables come in two forms: <em>artifacts</em> (for instance, EAR files) and <em>specifications</em> (for instance, a datasource).</p><h2>Deployeds</h2><p><em>Deployeds</em> are configuration items (CIs) that represent deployable CIs in their deployed form on the target container. The deployed CI specifies settings that are relevant for the CI on the container. </p><p>For example, a <code>wls.Ear</code> deployable is deployed to a <code>wls.Server</code> container, resulting in a <code>wls.EarModule</code> deployed.</p><p>Another example is a <code>wls.DataSourceSpec</code> that is deployed to a <code>wls.Server</code> container, resulting in a <code>wls.DataSource</code> deployed. The <code>wls.DataSource</code> is configured with the database username and password that are required to connect to the database from this particular server.</p><p>Deployeds go through the following life-cycle:</p>
<ul>
  <li>The deployed is created on a target container for the first time in an <em>initial</em> deployment</li>
  <li>The deployed is upgraded to a new version in an <em>upgrade</em> deployment</li>
  <li>The deployed is removed from the target container when it is <em>undeployed</em>.</li>
</ul><h2>Deploying an Application</h2><p>This process installs a particular application version (represented by a <em>deployment package</em>) on an environment. Deployit copies all necessary files and makes all configuration changes to the target middleware that are necessary for the application to run.</p><h2>Deployment Archive (DAR) Format</h2><p>The DAR format is the native format Deployit supports for <em>deployment packages</em>. A DAR file is a standard ZIP file with additional metadata information contained in a manifest. For a comprehensive description of the DAR format, see the <strong>Deployit Packaging Manual</strong>.</p><h2>Deployment Package</h2><p>In the <strong>Unified Deployment Model</strong>, a particular version of an application (consisting of both artifacts and resource specifications) is contained in a single <em>deployment package</em>. The package contains all <em>deployables</em> that the application needs. The package is environment-independent and can be deployed to any environment unchanged (see the <strong>Unified Deployment Model</strong>).</p><p>Deployit accepts packages in the Deployment ARchive (DAR) format.</p><h2>Dictionaries</h2><p>A dictionary is a CI that contains environment-specific entries for placeholder resolution. Entries can be added in the GUI or using the CLI. This allows the deployment package to remain environment-independent so it can be deployed unchanged to multiple environments.</p><p>For an example of using placeholders in CI properties, see the <strong>Deployit Packaging Manual</strong>.</p><h2>Directories</h2><p>A directory is a CI used for grouping other CIs. Directories exist directly below the repository root nodes and may be nested. Directories are also used to group security settings. </p><p>For example, you could create the directories <em>Administrative</em>, <em>Web</em> and <em>Financial</em> under the <strong>Applications</strong> node to group the available applications in these categories.</p><h2>Environment</h2><p>An <em>environment</em> is a grouping of infrastructure items, such as hosts, servers, clusters, etc. Environments can contain any combination of infrastructure items that are used in your situation. An environment is used as the target of a deployment, allowing <em>deployables</em> to be mapped to members of the environment.</p><h2>Orchestrators</h2><p>An <em>orchestrators</em> in Deployit combines the <em>steps</em> for the individual component changes into an overall deployment workflow. The default orchestrator "interleaves" all individual component changes by running all steps of a given order for all components (see <em>steplist</em> for an explanation of step order). This results in an overall workflow that first stops all containers, then removes all old components, then adds the new ones etc.</p><p>In addition to the default orchestrator, Deployit also ships with:</p>
<ul>
  <li><em>Container by container</em> orchestrator. This orchestrator groups steps that deal with the same container together, enabling deployments across a farm of middleware.</li>
  <li><em>Composite package</em> orchestrator. This orchestrator groups steps per contained package together. The order of the member packages in the composite package is preserved.</li>
  <li><em>Group</em> orchestrator (separate plugin). This orchestrator uses the <em>deployment group</em> synthetic property on a container to group steps for all containers with the same deployment group.</li>
</ul><p>See the <strong>Customization Manual</strong> for more information on creating a custom orchestrator.</p><h2>Placeholders</h2><p>Placeholders are configurable entries in your application that will be set to an actual value at deployment time. This allows the deployment package to be environment-independent and thus reusable. </p><p>There are two types of placeholders. <em>File</em> placeholders occur inside of artifacts in the deployment package. Deployit scans packages that it imports for text files and searches these text files for file placeholders. The following items are scanned:</p>
<ul>
  <li>File-type CIs</li>
  <li>Folder-type CIs</li>
  <li>Archive-type CIs</li>
</ul><p>Before a deployment can be performed, a value must be specified for <strong>all</strong> <em>file</em> placeholders in the deployment.</p><p><em>Property</em> placeholders are used in CI properties by specifying them in the package's manifest. In contrast to file placeholders, <em>property</em> placeholders do not necessarily need to have a value from a dictionary. If the placeholder can not be resolved from a dictionary, the placeholder is left as-is.</p><p>Deployit recognizes placeholders using the following format:</p>
<pre><code>{{PLACEHOLDER_KEY}}
</code></pre><p>Values for placeholders can be provided manually or filled in from a <em>dictionary</em>.</p><p>There are two special placeholder values:</p>
<ul>
  <li><em>&lt;empty&gt;</em> which replaces the placeholder key with an empty string</li>
  <li><em>&lt;ignore&gt;</em> which ignores the placeholder key, leaving it as-is</li>
</ul><h2>Plugin</h2><p>A <em>plugin</em> is a self-contained piece of functionality that adds capabilities to the Deployit system. Plugins are packaged in a JAR file and installed in Deployit's plugins directory. Plugins can contain:</p>
<ul>
  <li>Functionality to connect to specific middleware</li>
  <li>Host connection methods</li>
  <li>Custom importers</li>
</ul><h2>Repository</h2><p>Deployit's database is called the <em>repository</em>. It stpres all configuration items (CIs), binary files (such as <em>deployment packages</em>) and Deployit's security configuration (user accounts and rights). The repository can be stored on disk (default) or in a relational database (see <strong>Configuring Database Storage</strong> in the <strong>System Administration Manual</strong>).</p><p>Each CI in Deployit has an id that uniquely identifies the CI. This id is a path that determines the place of the CI in the repository. For instance, a CI with id "Applications/PetClinic/1.0" will appear in the <strong>PetClinic</strong> subfolder under the <strong>/Applications</strong> root folder.</p><p>The repository has a hierarchical layout and a version history. All CIs of all types are stored here. The top-level folders indicate the type of CI stored below it. Depending on the type of CI, the repository stores it under a particular folder:</p>
<ul>
  <li>Application CIs are stored under the <strong>/Applications</strong> folder.</li>
  <li>Environment and Dictionary CIs are stored under the <strong>/Environments</strong> folder.</li>
  <li>Middleware CIs (representing hosts, servers, etc.) are stored under the <strong>/Infrastructure</strong> folder.</li>
</ul><p>The repository acts as a version control system, that is, every change to every object in the repository is logged and stored. This makes it possible to compare a history of all changes to every CI in the repository. Deployit also retains the history of all changes to <em>deleted</em> CIs. Even if a CI is deleted, the storage it uses will not be freed up so that it is possible to retrieve the CI as it existed before the deletion. See the <strong>System Administration Manual</strong> for more information about managing the repository.</p><h3>Containment and References</h3><p>Deployit's repository contains CIs that refer to other CIs. There are two ways in which CIs can refer to each other:</p>
<ul>
  <li><strong>Containment</strong>. In this case, one CI <em>contains</em> another CI. If the parent CI is removed, so is the child CI. An example of this type of reference is an Environment CI and its deployed applications.</li>
  <li><strong>Reference</strong>. In this case, one CI <em>refers</em> to another CI. If the referring CI is removed, the referred CI is unchanged. Removing a CI when it is still being referred to is not allowed. An example of this type of reference is an Environment CI and its middleware. The middleware exists in the <strong>/Infrastructure</strong> folder independently of the environments the middleware is in.</li>
</ul><h3>Deployed Applications</h3><p>A deployed application is the result of deploying a <em>deployment package</em> to an <em>environment</em>. Deployed applications have a special structure in the repository. While performing the deployment, package members are installed as <em>deployed items</em> on individual environment members. In the repository, the <em>deployed application</em> CI is stored under the <em>Environment</em> node. Each of the <em>deployed items</em> are stored under the infrastructure members in the <em>Infrastructure</em> node.</p><p>So, deployed applications exist in both the <strong>/Environment</strong> as well as <strong>/Infrastructure</strong> folder. This has some consequences for the security setup. See the <strong>Deployit System Administration Manual</strong> for details.</p><h2>Resource Specifications</h2><p>Resource specifications are specifications of middleware resources that an application needs to run. The following are examples of these resources:</p>
<ul>
  <li>a datasource.</li>
  <li>a queue or topic.</li>
  <li>a connection factory.</li>
</ul><h2>Roles</h2><p>Roles are functional groups of <em>principals</em> (security users or groups) that are assigned a common set of permissions. In Deployit, permissions can <em>only</em> be assigned to roles. Roles are created and mapped to principals in Deployit itself, offering an additional layer of abstraction to the backend user store.</p><h2>Security</h2><p>Deployit supports a fine-grained access control scheme to ensure the security of your middleware and deployments. The security mechanism is based on the concepts of <em>principals</em> and <em>permissions</em>. A (security) principal is an entity that can be authenticated and that can be assigned rights over resources in Deployit. Principals are assigned certain permissions within the system. These permissions can be either global (that is, they apply to all of Deployit, such as login permission) or relevant for a particular CI or set of CIs (for instance, the permission to read certain CIs in the repository).</p><p>The security system uses the same permissions whether the system is accessed via the GUI or the CLI.</p><p>For more information about Deployit's security system, see the <strong>System Administration Manual</strong>.</p><h2>Step</h2><p>A step is a concrete action to be performed to accomplish a <em>task</em>. Steps are contributed by <em>plug-ins</em> based on the deployment that is being performed. All steps for a particular deployment are grouped together in a <em>steplist</em>. Deployit ships with many step implementations for common actions. Other, middleware-specific steps are contributed by the plugins.</p><p>The following are examples of steps:</p>
<ul>
  <li>Copy file /foo/bar to host1, directory /bar/baz.</li>
  <li>Install petclinic.ear on the WAS server on was1.</li>
  <li>Restart the Apache HTTP server on web1.</li>
</ul><h2>Steplist</h2><p>A steplist is a sequential list of <em>steps</em> that are contributed by one or more <em>plugins</em> when a deployment is being planned.</p><p>All steps in a steplist are ordered in a manner similar to /etc/init.d scripts in Unix, with low-order steps being executed before higher-order steps. Deployit predefines the following orders for ease of use:</p>
<ul>
  <li>0 = PRE_FLIGHT</li>
  <li>10 = STOP_ARTIFACTS</li>
  <li>20 = STOP_CONTAINERS</li>
  <li>30 = UNDEPLOY_ARTIFACTS</li>
  <li>40 = DESTROY_RESOURCES</li>
  <li>60 = CREATE_RESOURCES</li>
  <li>70 = DEPLOY_ARTIFACTS</li>
  <li>80 = START_CONTAINERS</li>
  <li>90 = START_ARTIFACTS</li>
  <li>100 = POST_FLIGHT</li>
</ul><h2>Tag-based Deployments</h2><p>Tags make it easier to configure deployments by marking which deployables should be mapped to which containers. </p><p>To perform a deployment using tags, specify tags on the deployables and containers. Tags can be specified either in the imported package or by using the repository browser. When deploying a package to an environment, Deployit will map deployables to containers that have at least one tag in common. If either the deployable or container has a tag, deployeds are only generated when at least one tag matches. A deployed is always generated if either the deployable or container doesn't have a tag.</p><p>An example scenario is deploying a front-end and back-end application to two application servers. By tagging the front-end EAR and front-end application server both with 'FE' and the back-end EAR and back-end server with 'BE', Deployit will automatically create the correct deployeds.</p><h2>Task</h2><p>A task is an activity in Deployit. When starting a deployment, Deployit will create and start a task. The task contains a list of <em>steps</em> that must be executed to successfully complete the task. Deployit will execute each of the steps in turn. When all of the steps are successfully executed, the task itself is successfully executed. If one of the steps fails, the task itself is marked stopped.</p><p>Deployit supports the following types of tasks:</p>
<ul>
  <li><strong>Deploy application</strong>. This task deploys a package onto an environment.</li>
  <li><strong>Update application</strong>. This task updates an existing deployment of an application.</li>
  <li><strong>Undeploy application</strong>. This task undeploys a package from an environment.</li>
  <li><strong>Discovery</strong>. This task discovers middleware on a host.</li>
</ul><h3>Task Recovery</h3><p>Deployit periodically stores a snapshot of the tasks in the system to be able to recover tasks if the server is stopped abruptly. Deployit will reload the tasks from the recovery file when it restarts. The tasks, deployed item configurations and generated steps will all be recovered. Tasks that were running in Deployit when the server stopped will be put in 'stopped' state so the user can decide whether to rerun or cancel it. Only tasks that have been started will be recovered.</p><h3>Queued Tasks</h3><p>When a task is started, Deployit schedules the task for immediate execution. Depending on the number of active tasks, the task may be executed immediately or it may be queued, waiting for an execution spot to open up. In the latter case, the task will be shown as <em>QUEUED</em> in the Deployit GUI.</p><h3>Task State</h3><p>Deployit allows a user to interact with the task. A user can:</p>
<ul>
  <li><strong>Start the task</strong>. Deplpyit will start executing the commands associated with the task.</li>
  <li><strong>Stop the task</strong>. Deployit will wait for the currently executing step to finish and will then cleanly stop the task. Note that, due to the nature of some steps, this is not always possible. For example, a step that calls an external script may hang indefinitely.</li>
  <li><strong>Abort the task</strong>. Deployit will attempt to kill the currently executing step. If successful, the aborted step and task are marked failed.</li>
  <li><strong>Cancel the task</strong>. Deployit will remove the task from the system. If the task was executing before, the task will be archived since it may have made changes to the middleware. If the task was pending and never started, it will be removed but not stored.</li>
</ul><h2>Type System</h2><p>Deployit features a configurable type system that allows modification and addition of CI types. This makes it possible to extend your installation of Deployit with new types or change existing types. Types defined in this manner are referred to as <em>synthetic</em> types. The type system is configured using XML files called <em>synthetic.xml</em>. All files containing synthetic types are read when the Deployit server starts and are available in the system afterwards.</p><p>Synthetic types are first-class citizens in Deployit and can be used in the same way that the built-in types are used. This means they can be included in deployment packages, used to specify your middleware topology and used to define and execute deployments. Synthetic types can also be edited in the Deployit GUI, including new types and added properties.</p><p>For more information about extending Deployit, see the <strong>Customization Manual</strong>.</p><h2>Undeploying an Application</h2><p>This process removes a <em>deployed application</em> from an <em>environment</em>. Deployit stops the application and undeploys all its components from the target middleware.</p><h2>Unified Deployment Model (UDM)</h2><p>The UDM is XebiaLabs' model for describing deployments and is used in Deployit. The UDM consists of the following components:</p>
<ul>
  <li><strong>Deployment Package</strong>. This is an environment-independent package containing <em>deployable</em> CIs that together form a complete application.</li>
  <li><strong>Environment</strong>. This is an environment containing <em>containers</em> (deployment targets, i.e. servers that applications can be deployed on). An example is a test environment containing a cluster of WebSphere servers.</li>
  <li><strong>Deployment</strong>. This is the process of configuring and installing a <em>deployment package</em> onto a specific <em>environment</em>. It results in <em>deployeds</em> describing the coupling of a <em>deployable</em> and a <em>container</em>.</li>
</ul><h2>Upgrading an Application</h2><p>This process replaces an application deployed to an <em>environment</em> with another version of the same application. When performing an upgrade, most <em>deployeds</em> can be inherited from the initial deployment. Deployit recognizes which artifacts in the deployment package have changed and deploys only the changed artifacts.</p></body></html>